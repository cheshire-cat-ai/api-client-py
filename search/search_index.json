{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cheshire Cat AI Python Client","text":""},{"location":"#cheshire-cat-ai-python-client","title":"Cheshire Cat AI Python Client","text":"<p>Coming soon...</p>"},{"location":"API_Documentation/SUMMARY/","title":"SUMMARY","text":"<ul> <li>api<ul> <li>embedder_api</li> <li>large_language_model_api</li> <li>memory_api</li> <li>plugins_api</li> <li>rabbit_hole_api</li> <li>settings_api</li> <li>status_api</li> </ul> </li> <li>api_client</li> <li>api_response</li> <li>cat_client</li> <li>config</li> <li>configuration</li> <li>exceptions</li> <li>models<ul> <li>body_upload_url</li> <li>http_validation_error</li> <li>location_inner</li> <li>setting_body</li> <li>validation_error</li> <li>value</li> </ul> </li> <li>rest</li> </ul>"},{"location":"API_Documentation/api_client/","title":"api_client","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient","title":"<code>ApiClient</code>","text":"<p>Generic API client for OpenAPI client library builds.</p> <p>OpenAPI generic API client. This client handles the client- server communication, and is invariant across implementations. Specifics of the methods and models for each application are generated from the OpenAPI templates.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <p>.Configuration object for this client</p> <code>None</code> <code>header_name</code> <p>a header to pass when making calls to the API.</p> <code>None</code> <code>header_value</code> <p>a header value to pass when making calls to the API.</p> <code>None</code> <code>cookie</code> <p>a cookie to include in the header when making calls to the API</p> <code>None</code> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>class ApiClient:\n    \"\"\"Generic API client for OpenAPI client library builds.\n\n    OpenAPI generic API client. This client handles the client-\n    server communication, and is invariant across implementations. Specifics of\n    the methods and models for each application are generated from the OpenAPI\n    templates.\n\n    :param configuration: .Configuration object for this client\n    :param header_name: a header to pass when making calls to the API.\n    :param header_value: a header value to pass when making calls to\n        the API.\n    :param cookie: a cookie to include in the header when making calls\n        to the API\n    \"\"\"\n\n    PRIMITIVE_TYPES = (float, bool, bytes, str, int)\n    NATIVE_TYPES_MAPPING = {\n        'int': int,\n        'long': int, # TODO remove as only py3 is supported?\n        'float': float,\n        'str': str,\n        'bool': bool,\n        'date': datetime.date,\n        'datetime': datetime.datetime,\n        'object': object,\n    }\n    _pool = None\n\n    def __init__(\n        self,\n        configuration=None,\n        header_name=None,\n        header_value=None,\n        cookie=None\n    ) -&gt; None:\n        # use default configuration if none is provided\n        if configuration is None:\n            configuration = Configuration.get_default()\n        self.configuration = configuration\n\n        self.rest_client = rest.RESTClientObject(configuration)\n        self.default_headers = {}\n        if header_name is not None:\n            self.default_headers[header_name] = header_value\n        self.cookie = cookie\n        # Set default User-Agent.\n        self.user_agent = 'OpenAPI-Generator/1.0.0/python'\n        self.client_side_validation = configuration.client_side_validation\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        pass\n\n    @property\n    def user_agent(self):\n        \"\"\"User agent for this API client\"\"\"\n        return self.default_headers['User-Agent']\n\n    @user_agent.setter\n    def user_agent(self, value):\n        self.default_headers['User-Agent'] = value\n\n    def set_default_header(self, header_name, header_value):\n        self.default_headers[header_name] = header_value\n\n\n    _default = None\n\n    @classmethod\n    def get_default(cls):\n        \"\"\"Return new instance of ApiClient.\n\n        This method returns newly created, based on default constructor,\n        object of ApiClient class or returns a copy of default\n        ApiClient.\n\n        :return: The ApiClient object.\n        \"\"\"\n        if cls._default is None:\n            cls._default = ApiClient()\n        return cls._default\n\n    @classmethod\n    def set_default(cls, default):\n        \"\"\"Set default instance of ApiClient.\n\n        It stores default ApiClient.\n\n        :param default: object of ApiClient.\n        \"\"\"\n        cls._default = default\n\n    def param_serialize(\n        self,\n        method,\n        resource_path,\n        path_params=None,\n        query_params=None,\n        header_params=None,\n        body=None,\n        post_params=None,\n        files=None, auth_settings=None,\n        collection_formats=None,\n        _host=None,\n        _request_auth=None\n    ) -&gt; Tuple:\n\n        \"\"\"Builds the HTTP request params needed by the request.\n        :param method: Method to call.\n        :param resource_path: Path to method endpoint.\n        :param path_params: Path parameters in the url.\n        :param query_params: Query parameters in the url.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param auth_settings list: Auth Settings names for the request.\n        :param files dict: key -&gt; filename, value -&gt; filepath,\n            for `multipart/form-data`.\n        :param collection_formats: dict of collection formats for path, query,\n            header, and post parameters.\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the authentication\n                              in the spec for a single request.\n        :return: tuple of form (path, http_method, query_params, header_params,\n            body, post_params, files)\n        \"\"\"\n\n        config = self.configuration\n\n        # header parameters\n        header_params = header_params or {}\n        header_params.update(self.default_headers)\n        if self.cookie:\n            header_params['Cookie'] = self.cookie\n        if header_params:\n            header_params = self.sanitize_for_serialization(header_params)\n            header_params = dict(\n                self.parameters_to_tuples(header_params,collection_formats)\n            )\n\n        # path parameters\n        if path_params:\n            path_params = self.sanitize_for_serialization(path_params)\n            path_params = self.parameters_to_tuples(\n                path_params,\n                collection_formats\n            )\n            for k, v in path_params:\n                # specified safe chars, encode everything\n                resource_path = resource_path.replace(\n                    '{%s}' % k,\n                    quote(str(v), safe=config.safe_chars_for_path_param)\n                )\n\n        # post parameters\n        if post_params or files:\n            post_params = post_params if post_params else []\n            post_params = self.sanitize_for_serialization(post_params)\n            post_params = self.parameters_to_tuples(\n                post_params,\n                collection_formats\n            )\n            post_params.extend(self.files_parameters(files))\n\n        # auth setting\n        self.update_params_for_auth(\n            header_params,\n            query_params,\n            auth_settings,\n            resource_path,\n            method,\n            body,\n            request_auth=_request_auth\n        )\n\n        # body\n        if body:\n            body = self.sanitize_for_serialization(body)\n\n        # request url\n        if _host is None:\n            url = self.configuration.host + resource_path\n        else:\n            # use server/host defined in path or operation instead\n            url = _host + resource_path\n\n        # query parameters\n        if query_params:\n            query_params = self.sanitize_for_serialization(query_params)\n            url_query = self.parameters_to_url_query(\n                query_params,\n                collection_formats\n            )\n            url += \"?\" + url_query\n\n        return method, url, header_params, body, post_params\n\n\n    def call_api(\n        self,\n        method,\n        url,\n        header_params=None,\n        body=None,\n        post_params=None,\n        _request_timeout=None\n    ) -&gt; rest.RESTResponse:\n        \"\"\"Makes the HTTP request (synchronous)\n        :param method: Method to call.\n        :param url: Path to method endpoint.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param _request_timeout: timeout setting for this request.\n        :return: RESTResponse\n        \"\"\"\n\n        try:\n            # perform request and return response\n            response_data = self.rest_client.request(\n                method, url,\n                headers=header_params,\n                body=body, post_params=post_params,\n                _request_timeout=_request_timeout\n            )\n\n        except ApiException as e:\n            if e.body:\n                e.body = e.body.decode('utf-8')\n            raise e\n\n        return response_data\n\n    def response_deserialize(\n        self,\n        response_data=None,\n        response_types_map=None\n    ) -&gt; ApiResponse:\n        \"\"\"Deserializes response into an object.\n        :param response_data: RESTResponse object to be deserialized.\n        :param response_types_map: dict of response types.\n        :return: ApiResponse\n        \"\"\"\n\n\n        response_type = response_types_map.get(str(response_data.status), None)\n        if not response_type and isinstance(response_data.status, int) and 100 &lt;= response_data.status &lt;= 599:\n            # if not found, look for '1XX', '2XX', etc.\n            response_type = response_types_map.get(str(response_data.status)[0] + \"XX\", None)\n\n        if not 200 &lt;= response_data.status &lt;= 299:\n            if response_data.status == 400:\n                raise BadRequestException(http_resp=response_data)\n\n            if response_data.status == 401:\n                raise UnauthorizedException(http_resp=response_data)\n\n            if response_data.status == 403:\n                raise ForbiddenException(http_resp=response_data)\n\n            if response_data.status == 404:\n                raise NotFoundException(http_resp=response_data)\n\n            if 500 &lt;= response_data.status &lt;= 599:\n                raise ServiceException(http_resp=response_data)\n            raise ApiException(http_resp=response_data)\n\n        # deserialize response data\n\n        if response_type == \"bytearray\":\n            return_data = response_data.data\n        elif response_type is None:\n            return_data = None\n        elif response_type == \"file\":\n            return_data = self.__deserialize_file(response_data)\n        else:\n            match = None\n            content_type = response_data.getheader('content-type')\n            if content_type is not None:\n                match = re.search(r\"charset=([a-zA-Z\\-\\d]+)[\\s;]?\", content_type)\n            encoding = match.group(1) if match else \"utf-8\"\n            response_text = response_data.data.decode(encoding)\n            return_data = self.deserialize(response_text, response_type)\n\n        return ApiResponse(\n            status_code = response_data.status,\n            data = return_data,\n            headers = response_data.getheaders(),\n            raw_data = response_data.data\n        )\n\n    def sanitize_for_serialization(self, obj):\n        \"\"\"Builds a JSON POST object.\n\n        If obj is None, return None.\n        If obj is str, int, long, float, bool, return directly.\n        If obj is datetime.datetime, datetime.date\n            convert to string in iso8601 format.\n        If obj is list, sanitize each element in the list.\n        If obj is dict, return the dict.\n        If obj is OpenAPI model, return the properties dict.\n\n        :param obj: The data to serialize.\n        :return: The serialized form of data.\n        \"\"\"\n        if obj is None:\n            return None\n        elif isinstance(obj, self.PRIMITIVE_TYPES):\n            return obj\n        elif isinstance(obj, list):\n            return [\n                self.sanitize_for_serialization(sub_obj) for sub_obj in obj\n            ]\n        elif isinstance(obj, tuple):\n            return tuple(\n                self.sanitize_for_serialization(sub_obj) for sub_obj in obj\n            )\n        elif isinstance(obj, (datetime.datetime, datetime.date)):\n            return obj.isoformat()\n\n        elif isinstance(obj, dict):\n            obj_dict = obj\n        else:\n            # Convert model obj to dict except\n            # attributes `openapi_types`, `attribute_map`\n            # and attributes which value is not None.\n            # Convert attribute name to json key in\n            # model definition for request.\n            obj_dict = obj.to_dict()\n\n        return {\n            key: self.sanitize_for_serialization(val)\n            for key, val in obj_dict.items()\n        }\n\n    def deserialize(self, response_text, response_type):\n        \"\"\"Deserializes response into an object.\n\n        :param response: RESTResponse object to be deserialized.\n        :param response_type: class literal for\n            deserialized object, or string of class name.\n\n        :return: deserialized object.\n        \"\"\"\n\n        # fetch data from response object\n        try:\n            data = json.loads(response_text)\n        except ValueError:\n            data = response_text\n\n        return self.__deserialize(data, response_type)\n\n    def __deserialize(self, data, klass):\n        \"\"\"Deserializes dict, list, str into an object.\n\n        :param data: dict, list or str.\n        :param klass: class literal, or string of class name.\n\n        :return: object.\n        \"\"\"\n        if data is None:\n            return None\n\n        if isinstance(klass, str):\n            if klass.startswith('List['):\n                sub_kls = re.match(r'List\\[(.*)]', klass).group(1)\n                return [self.__deserialize(sub_data, sub_kls)\n                        for sub_data in data]\n\n            if klass.startswith('Dict['):\n                sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)\n                return {k: self.__deserialize(v, sub_kls)\n                        for k, v in data.items()}\n\n            # convert str to class\n            if klass in self.NATIVE_TYPES_MAPPING:\n                klass = self.NATIVE_TYPES_MAPPING[klass]\n            else:\n                klass = getattr(cheshire_cat_api.models, klass)\n\n        if klass in self.PRIMITIVE_TYPES:\n            return self.__deserialize_primitive(data, klass)\n        elif klass == object:\n            return self.__deserialize_object(data)\n        elif klass == datetime.date:\n            return self.__deserialize_date(data)\n        elif klass == datetime.datetime:\n            return self.__deserialize_datetime(data)\n        else:\n            return self.__deserialize_model(data, klass)\n\n    def parameters_to_tuples(self, params, collection_formats):\n        \"\"\"Get parameters as list of tuples, formatting collections.\n\n        :param params: Parameters as dict or list of two-tuples\n        :param dict collection_formats: Parameter collection formats\n        :return: Parameters as list of tuples, collections formatted\n        \"\"\"\n        new_params = []\n        if collection_formats is None:\n            collection_formats = {}\n        for k, v in params.items() if isinstance(params, dict) else params:\n            if k in collection_formats:\n                collection_format = collection_formats[k]\n                if collection_format == 'multi':\n                    new_params.extend((k, value) for value in v)\n                else:\n                    if collection_format == 'ssv':\n                        delimiter = ' '\n                    elif collection_format == 'tsv':\n                        delimiter = '\\t'\n                    elif collection_format == 'pipes':\n                        delimiter = '|'\n                    else:  # csv is the default\n                        delimiter = ','\n                    new_params.append(\n                        (k, delimiter.join(str(value) for value in v)))\n            else:\n                new_params.append((k, v))\n        return new_params\n\n    def parameters_to_url_query(self, params, collection_formats):\n        \"\"\"Get parameters as list of tuples, formatting collections.\n\n        :param params: Parameters as dict or list of two-tuples\n        :param dict collection_formats: Parameter collection formats\n        :return: URL query string (e.g. a=Hello%20World&amp;b=123)\n        \"\"\"\n        new_params = []\n        if collection_formats is None:\n            collection_formats = {}\n        for k, v in params.items() if isinstance(params, dict) else params:\n            if isinstance(v, bool):\n                v = str(v).lower()\n            if isinstance(v, (int, float)):\n                v = str(v)\n            if isinstance(v, dict):\n                v = json.dumps(v)\n\n            if k in collection_formats:\n                collection_format = collection_formats[k]\n                if collection_format == 'multi':\n                    new_params.extend((k, value) for value in v)\n                else:\n                    if collection_format == 'ssv':\n                        delimiter = ' '\n                    elif collection_format == 'tsv':\n                        delimiter = '\\t'\n                    elif collection_format == 'pipes':\n                        delimiter = '|'\n                    else:  # csv is the default\n                        delimiter = ','\n                    new_params.append(\n                        (k, delimiter.join(quote(str(value)) for value in v))\n                    )\n            else:\n                new_params.append((k, quote(str(v))))\n\n        return \"&amp;\".join([\"=\".join(item) for item in new_params])\n\n    def files_parameters(self, files=None):\n        \"\"\"Builds form parameters.\n\n        :param files: File parameters.\n        :return: Form parameters with files.\n        \"\"\"\n        params = []\n\n        if files:\n            for k, v in files.items():\n                if not v:\n                    continue\n                file_names = v if type(v) is list else [v]\n                for n in file_names:\n                    with open(n, 'rb') as f:\n                        filename = os.path.basename(f.name)\n                        filedata = f.read()\n                        mimetype = (\n                            mimetypes.guess_type(filename)[0]\n                            or 'application/octet-stream'\n                        )\n                        params.append(\n                            tuple([k, tuple([filename, filedata, mimetype])])\n                        )\n\n        return params\n\n    def select_header_accept(self, accepts: List[str]) -&gt; Optional[str]:\n        \"\"\"Returns `Accept` based on an array of accepts provided.\n\n        :param accepts: List of headers.\n        :return: Accept (e.g. application/json).\n        \"\"\"\n        if not accepts:\n            return None\n\n        for accept in accepts:\n            if re.search('json', accept, re.IGNORECASE):\n                return accept\n\n        return accepts[0]\n\n    def select_header_content_type(self, content_types):\n        \"\"\"Returns `Content-Type` based on an array of content_types provided.\n\n        :param content_types: List of content-types.\n        :return: Content-Type (e.g. application/json).\n        \"\"\"\n        if not content_types:\n            return None\n\n        for content_type in content_types:\n            if re.search('json', content_type, re.IGNORECASE):\n                return content_type\n\n        return content_types[0]\n\n    def update_params_for_auth(\n        self,\n        headers,\n        queries,\n        auth_settings,\n        resource_path,\n        method,\n        body,\n        request_auth=None\n    ) -&gt; None:\n        \"\"\"Updates header and query params based on authentication setting.\n\n        :param headers: Header parameters dict to be updated.\n        :param queries: Query parameters tuple list to be updated.\n        :param auth_settings: Authentication setting identifiers list.\n        :resource_path: A string representation of the HTTP request resource path.\n        :method: A string representation of the HTTP request method.\n        :body: A object representing the body of the HTTP request.\n        The object type is the return value of sanitize_for_serialization().\n        :param request_auth: if set, the provided settings will\n                             override the token in the configuration.\n        \"\"\"\n        if not auth_settings:\n            return\n\n        if request_auth:\n            self._apply_auth_params(\n                headers,\n                queries,\n                resource_path,\n                method,\n                body,\n                request_auth\n            )\n        else:\n            for auth in auth_settings:\n                auth_setting = self.configuration.auth_settings().get(auth)\n                if auth_setting:\n                    self._apply_auth_params(\n                        headers,\n                        queries,\n                        resource_path,\n                        method,\n                        body,\n                        auth_setting\n                    )\n\n    def _apply_auth_params(\n        self,\n        headers,\n        queries,\n        resource_path,\n        method,\n        body,\n        auth_setting\n    ) -&gt; None:\n        \"\"\"Updates the request parameters based on a single auth_setting\n\n        :param headers: Header parameters dict to be updated.\n        :param queries: Query parameters tuple list to be updated.\n        :resource_path: A string representation of the HTTP request resource path.\n        :method: A string representation of the HTTP request method.\n        :body: A object representing the body of the HTTP request.\n        The object type is the return value of sanitize_for_serialization().\n        :param auth_setting: auth settings for the endpoint\n        \"\"\"\n        if auth_setting['in'] == 'cookie':\n            headers['Cookie'] = auth_setting['value']\n        elif auth_setting['in'] == 'header':\n            if auth_setting['type'] != 'http-signature':\n                headers[auth_setting['key']] = auth_setting['value']\n        elif auth_setting['in'] == 'query':\n            queries.append((auth_setting['key'], auth_setting['value']))\n        else:\n            raise ApiValueError(\n                'Authentication token must be in `query` or `header`'\n            )\n\n    def __deserialize_file(self, response):\n        \"\"\"Deserializes body to file\n\n        Saves response body into a file in a temporary folder,\n        using the filename from the `Content-Disposition` header if provided.\n\n        handle file downloading\n        save response body into a tmp file and return the instance\n\n        :param response:  RESTResponse.\n        :return: file path.\n        \"\"\"\n        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)\n        os.close(fd)\n        os.remove(path)\n\n        content_disposition = response.getheader(\"Content-Disposition\")\n        if content_disposition:\n            filename = re.search(\n                r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?',\n                content_disposition\n            ).group(1)\n            path = os.path.join(os.path.dirname(path), filename)\n\n        with open(path, \"wb\") as f:\n            f.write(response.data)\n\n        return path\n\n    def __deserialize_primitive(self, data, klass):\n        \"\"\"Deserializes string to primitive type.\n\n        :param data: str.\n        :param klass: class literal.\n\n        :return: int, long, float, str, bool.\n        \"\"\"\n        try:\n            return klass(data)\n        except UnicodeEncodeError:\n            return str(data)\n        except TypeError:\n            return data\n\n    def __deserialize_object(self, value):\n        \"\"\"Return an original value.\n\n        :return: object.\n        \"\"\"\n        return value\n\n    def __deserialize_date(self, string):\n        \"\"\"Deserializes string to date.\n\n        :param string: str.\n        :return: date.\n        \"\"\"\n        try:\n            return parse(string).date()\n        except ImportError:\n            return string\n        except ValueError:\n            raise rest.ApiException(\n                status=0,\n                reason=\"Failed to parse `{0}` as date object\".format(string)\n            )\n\n    def __deserialize_datetime(self, string):\n        \"\"\"Deserializes string to datetime.\n\n        The string should be in iso8601 datetime format.\n\n        :param string: str.\n        :return: datetime.\n        \"\"\"\n        try:\n            return parse(string)\n        except ImportError:\n            return string\n        except ValueError:\n            raise rest.ApiException(\n                status=0,\n                reason=(\n                    \"Failed to parse `{0}` as datetime object\"\n                    .format(string)\n                )\n            )\n\n    def __deserialize_model(self, data, klass):\n        \"\"\"Deserializes list or dict to model.\n\n        :param data: dict, list.\n        :param klass: class literal.\n        :return: model object.\n        \"\"\"\n\n        return klass.from_dict(data)\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.user_agent","title":"<code>user_agent</code>  <code>property</code> <code>writable</code>","text":"<p>User agent for this API client</p>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.__deserialize","title":"<code>__deserialize(data, klass)</code>","text":"<p>Deserializes dict, list, str into an object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>dict, list or str.</p> required <code>klass</code> <p>class literal, or string of class name.</p> required <p>Returns:</p> Type Description <p>object.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def __deserialize(self, data, klass):\n    \"\"\"Deserializes dict, list, str into an object.\n\n    :param data: dict, list or str.\n    :param klass: class literal, or string of class name.\n\n    :return: object.\n    \"\"\"\n    if data is None:\n        return None\n\n    if isinstance(klass, str):\n        if klass.startswith('List['):\n            sub_kls = re.match(r'List\\[(.*)]', klass).group(1)\n            return [self.__deserialize(sub_data, sub_kls)\n                    for sub_data in data]\n\n        if klass.startswith('Dict['):\n            sub_kls = re.match(r'Dict\\[([^,]*), (.*)]', klass).group(2)\n            return {k: self.__deserialize(v, sub_kls)\n                    for k, v in data.items()}\n\n        # convert str to class\n        if klass in self.NATIVE_TYPES_MAPPING:\n            klass = self.NATIVE_TYPES_MAPPING[klass]\n        else:\n            klass = getattr(cheshire_cat_api.models, klass)\n\n    if klass in self.PRIMITIVE_TYPES:\n        return self.__deserialize_primitive(data, klass)\n    elif klass == object:\n        return self.__deserialize_object(data)\n    elif klass == datetime.date:\n        return self.__deserialize_date(data)\n    elif klass == datetime.datetime:\n        return self.__deserialize_datetime(data)\n    else:\n        return self.__deserialize_model(data, klass)\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.__deserialize_date","title":"<code>__deserialize_date(string)</code>","text":"<p>Deserializes string to date.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <p>str.</p> required <p>Returns:</p> Type Description <p>date.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def __deserialize_date(self, string):\n    \"\"\"Deserializes string to date.\n\n    :param string: str.\n    :return: date.\n    \"\"\"\n    try:\n        return parse(string).date()\n    except ImportError:\n        return string\n    except ValueError:\n        raise rest.ApiException(\n            status=0,\n            reason=\"Failed to parse `{0}` as date object\".format(string)\n        )\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.__deserialize_datetime","title":"<code>__deserialize_datetime(string)</code>","text":"<p>Deserializes string to datetime.</p> <p>The string should be in iso8601 datetime format.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <p>str.</p> required <p>Returns:</p> Type Description <p>datetime.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def __deserialize_datetime(self, string):\n    \"\"\"Deserializes string to datetime.\n\n    The string should be in iso8601 datetime format.\n\n    :param string: str.\n    :return: datetime.\n    \"\"\"\n    try:\n        return parse(string)\n    except ImportError:\n        return string\n    except ValueError:\n        raise rest.ApiException(\n            status=0,\n            reason=(\n                \"Failed to parse `{0}` as datetime object\"\n                .format(string)\n            )\n        )\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.__deserialize_file","title":"<code>__deserialize_file(response)</code>","text":"<p>Deserializes body to file</p> <p>Saves response body into a file in a temporary folder, using the filename from the <code>Content-Disposition</code> header if provided.</p> <p>handle file downloading save response body into a tmp file and return the instance</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <p>RESTResponse.</p> required <p>Returns:</p> Type Description <p>file path.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def __deserialize_file(self, response):\n    \"\"\"Deserializes body to file\n\n    Saves response body into a file in a temporary folder,\n    using the filename from the `Content-Disposition` header if provided.\n\n    handle file downloading\n    save response body into a tmp file and return the instance\n\n    :param response:  RESTResponse.\n    :return: file path.\n    \"\"\"\n    fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)\n    os.close(fd)\n    os.remove(path)\n\n    content_disposition = response.getheader(\"Content-Disposition\")\n    if content_disposition:\n        filename = re.search(\n            r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?',\n            content_disposition\n        ).group(1)\n        path = os.path.join(os.path.dirname(path), filename)\n\n    with open(path, \"wb\") as f:\n        f.write(response.data)\n\n    return path\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.__deserialize_model","title":"<code>__deserialize_model(data, klass)</code>","text":"<p>Deserializes list or dict to model.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>dict, list.</p> required <code>klass</code> <p>class literal.</p> required <p>Returns:</p> Type Description <p>model object.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def __deserialize_model(self, data, klass):\n    \"\"\"Deserializes list or dict to model.\n\n    :param data: dict, list.\n    :param klass: class literal.\n    :return: model object.\n    \"\"\"\n\n    return klass.from_dict(data)\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.__deserialize_object","title":"<code>__deserialize_object(value)</code>","text":"<p>Return an original value.</p> <p>Returns:</p> Type Description <p>object.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def __deserialize_object(self, value):\n    \"\"\"Return an original value.\n\n    :return: object.\n    \"\"\"\n    return value\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.__deserialize_primitive","title":"<code>__deserialize_primitive(data, klass)</code>","text":"<p>Deserializes string to primitive type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>str.</p> required <code>klass</code> <p>class literal.</p> required <p>Returns:</p> Type Description <p>int, long, float, str, bool.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def __deserialize_primitive(self, data, klass):\n    \"\"\"Deserializes string to primitive type.\n\n    :param data: str.\n    :param klass: class literal.\n\n    :return: int, long, float, str, bool.\n    \"\"\"\n    try:\n        return klass(data)\n    except UnicodeEncodeError:\n        return str(data)\n    except TypeError:\n        return data\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient._apply_auth_params","title":"<code>_apply_auth_params(headers, queries, resource_path, method, body, auth_setting)</code>","text":"<p>Updates the request parameters based on a single auth_setting</p> <p>:resource_path: A string representation of the HTTP request resource path. :method: A string representation of the HTTP request method. :body: A object representing the body of the HTTP request. The object type is the return value of sanitize_for_serialization().</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <p>Header parameters dict to be updated.</p> required <code>queries</code> <p>Query parameters tuple list to be updated.</p> required <code>auth_setting</code> <p>auth settings for the endpoint</p> required Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def _apply_auth_params(\n    self,\n    headers,\n    queries,\n    resource_path,\n    method,\n    body,\n    auth_setting\n) -&gt; None:\n    \"\"\"Updates the request parameters based on a single auth_setting\n\n    :param headers: Header parameters dict to be updated.\n    :param queries: Query parameters tuple list to be updated.\n    :resource_path: A string representation of the HTTP request resource path.\n    :method: A string representation of the HTTP request method.\n    :body: A object representing the body of the HTTP request.\n    The object type is the return value of sanitize_for_serialization().\n    :param auth_setting: auth settings for the endpoint\n    \"\"\"\n    if auth_setting['in'] == 'cookie':\n        headers['Cookie'] = auth_setting['value']\n    elif auth_setting['in'] == 'header':\n        if auth_setting['type'] != 'http-signature':\n            headers[auth_setting['key']] = auth_setting['value']\n    elif auth_setting['in'] == 'query':\n        queries.append((auth_setting['key'], auth_setting['value']))\n    else:\n        raise ApiValueError(\n            'Authentication token must be in `query` or `header`'\n        )\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.call_api","title":"<code>call_api(method, url, header_params=None, body=None, post_params=None, _request_timeout=None)</code>","text":"<p>Makes the HTTP request (synchronous)</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>Method to call.</p> required <code>url</code> <p>Path to method endpoint.</p> required <code>header_params</code> <p>Header parameters to be placed in the request header.</p> <code>None</code> <code>body</code> <p>Request body.</p> <code>None</code> <code>dict</code> <code>post_params</code> <p>Request post form parameters, for <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>.</p> required <code>_request_timeout</code> <p>timeout setting for this request.</p> <code>None</code> <p>Returns:</p> Type Description <code>RESTResponse</code> <p>RESTResponse</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def call_api(\n    self,\n    method,\n    url,\n    header_params=None,\n    body=None,\n    post_params=None,\n    _request_timeout=None\n) -&gt; rest.RESTResponse:\n    \"\"\"Makes the HTTP request (synchronous)\n    :param method: Method to call.\n    :param url: Path to method endpoint.\n    :param header_params: Header parameters to be\n        placed in the request header.\n    :param body: Request body.\n    :param post_params dict: Request post form parameters,\n        for `application/x-www-form-urlencoded`, `multipart/form-data`.\n    :param _request_timeout: timeout setting for this request.\n    :return: RESTResponse\n    \"\"\"\n\n    try:\n        # perform request and return response\n        response_data = self.rest_client.request(\n            method, url,\n            headers=header_params,\n            body=body, post_params=post_params,\n            _request_timeout=_request_timeout\n        )\n\n    except ApiException as e:\n        if e.body:\n            e.body = e.body.decode('utf-8')\n        raise e\n\n    return response_data\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.deserialize","title":"<code>deserialize(response_text, response_type)</code>","text":"<p>Deserializes response into an object.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <p>RESTResponse object to be deserialized.</p> required <code>response_type</code> <p>class literal for deserialized object, or string of class name.</p> required <p>Returns:</p> Type Description <p>deserialized object.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def deserialize(self, response_text, response_type):\n    \"\"\"Deserializes response into an object.\n\n    :param response: RESTResponse object to be deserialized.\n    :param response_type: class literal for\n        deserialized object, or string of class name.\n\n    :return: deserialized object.\n    \"\"\"\n\n    # fetch data from response object\n    try:\n        data = json.loads(response_text)\n    except ValueError:\n        data = response_text\n\n    return self.__deserialize(data, response_type)\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.files_parameters","title":"<code>files_parameters(files=None)</code>","text":"<p>Builds form parameters.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <p>File parameters.</p> <code>None</code> <p>Returns:</p> Type Description <p>Form parameters with files.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def files_parameters(self, files=None):\n    \"\"\"Builds form parameters.\n\n    :param files: File parameters.\n    :return: Form parameters with files.\n    \"\"\"\n    params = []\n\n    if files:\n        for k, v in files.items():\n            if not v:\n                continue\n            file_names = v if type(v) is list else [v]\n            for n in file_names:\n                with open(n, 'rb') as f:\n                    filename = os.path.basename(f.name)\n                    filedata = f.read()\n                    mimetype = (\n                        mimetypes.guess_type(filename)[0]\n                        or 'application/octet-stream'\n                    )\n                    params.append(\n                        tuple([k, tuple([filename, filedata, mimetype])])\n                    )\n\n    return params\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.get_default","title":"<code>get_default()</code>  <code>classmethod</code>","text":"<p>Return new instance of ApiClient.</p> <p>This method returns newly created, based on default constructor, object of ApiClient class or returns a copy of default ApiClient.</p> <p>Returns:</p> Type Description <p>The ApiClient object.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>@classmethod\ndef get_default(cls):\n    \"\"\"Return new instance of ApiClient.\n\n    This method returns newly created, based on default constructor,\n    object of ApiClient class or returns a copy of default\n    ApiClient.\n\n    :return: The ApiClient object.\n    \"\"\"\n    if cls._default is None:\n        cls._default = ApiClient()\n    return cls._default\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.param_serialize","title":"<code>param_serialize(method, resource_path, path_params=None, query_params=None, header_params=None, body=None, post_params=None, files=None, auth_settings=None, collection_formats=None, _host=None, _request_auth=None)</code>","text":"<p>Builds the HTTP request params needed by the request.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>Method to call.</p> required <code>resource_path</code> <p>Path to method endpoint.</p> required <code>path_params</code> <p>Path parameters in the url.</p> <code>None</code> <code>query_params</code> <p>Query parameters in the url.</p> <code>None</code> <code>header_params</code> <p>Header parameters to be placed in the request header.</p> <code>None</code> <code>body</code> <p>Request body.</p> <code>None</code> <code>dict</code> <code>post_params</code> <p>Request post form parameters, for <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>.</p> required <code>list</code> <code>auth_settings</code> <p>Auth Settings names for the request.</p> required <code>collection_formats</code> <p>dict of collection formats for path, query, header, and post parameters.</p> <code>None</code> <code>_request_auth</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple of form (path, http_method, query_params, header_params, body, post_params, files)</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def param_serialize(\n    self,\n    method,\n    resource_path,\n    path_params=None,\n    query_params=None,\n    header_params=None,\n    body=None,\n    post_params=None,\n    files=None, auth_settings=None,\n    collection_formats=None,\n    _host=None,\n    _request_auth=None\n) -&gt; Tuple:\n\n    \"\"\"Builds the HTTP request params needed by the request.\n    :param method: Method to call.\n    :param resource_path: Path to method endpoint.\n    :param path_params: Path parameters in the url.\n    :param query_params: Query parameters in the url.\n    :param header_params: Header parameters to be\n        placed in the request header.\n    :param body: Request body.\n    :param post_params dict: Request post form parameters,\n        for `application/x-www-form-urlencoded`, `multipart/form-data`.\n    :param auth_settings list: Auth Settings names for the request.\n    :param files dict: key -&gt; filename, value -&gt; filepath,\n        for `multipart/form-data`.\n    :param collection_formats: dict of collection formats for path, query,\n        header, and post parameters.\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the authentication\n                          in the spec for a single request.\n    :return: tuple of form (path, http_method, query_params, header_params,\n        body, post_params, files)\n    \"\"\"\n\n    config = self.configuration\n\n    # header parameters\n    header_params = header_params or {}\n    header_params.update(self.default_headers)\n    if self.cookie:\n        header_params['Cookie'] = self.cookie\n    if header_params:\n        header_params = self.sanitize_for_serialization(header_params)\n        header_params = dict(\n            self.parameters_to_tuples(header_params,collection_formats)\n        )\n\n    # path parameters\n    if path_params:\n        path_params = self.sanitize_for_serialization(path_params)\n        path_params = self.parameters_to_tuples(\n            path_params,\n            collection_formats\n        )\n        for k, v in path_params:\n            # specified safe chars, encode everything\n            resource_path = resource_path.replace(\n                '{%s}' % k,\n                quote(str(v), safe=config.safe_chars_for_path_param)\n            )\n\n    # post parameters\n    if post_params or files:\n        post_params = post_params if post_params else []\n        post_params = self.sanitize_for_serialization(post_params)\n        post_params = self.parameters_to_tuples(\n            post_params,\n            collection_formats\n        )\n        post_params.extend(self.files_parameters(files))\n\n    # auth setting\n    self.update_params_for_auth(\n        header_params,\n        query_params,\n        auth_settings,\n        resource_path,\n        method,\n        body,\n        request_auth=_request_auth\n    )\n\n    # body\n    if body:\n        body = self.sanitize_for_serialization(body)\n\n    # request url\n    if _host is None:\n        url = self.configuration.host + resource_path\n    else:\n        # use server/host defined in path or operation instead\n        url = _host + resource_path\n\n    # query parameters\n    if query_params:\n        query_params = self.sanitize_for_serialization(query_params)\n        url_query = self.parameters_to_url_query(\n            query_params,\n            collection_formats\n        )\n        url += \"?\" + url_query\n\n    return method, url, header_params, body, post_params\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.parameters_to_tuples","title":"<code>parameters_to_tuples(params, collection_formats)</code>","text":"<p>Get parameters as list of tuples, formatting collections.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>Parameters as dict or list of two-tuples</p> required <code>collection_formats</code> <code>dict</code> <p>Parameter collection formats</p> required <p>Returns:</p> Type Description <p>Parameters as list of tuples, collections formatted</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def parameters_to_tuples(self, params, collection_formats):\n    \"\"\"Get parameters as list of tuples, formatting collections.\n\n    :param params: Parameters as dict or list of two-tuples\n    :param dict collection_formats: Parameter collection formats\n    :return: Parameters as list of tuples, collections formatted\n    \"\"\"\n    new_params = []\n    if collection_formats is None:\n        collection_formats = {}\n    for k, v in params.items() if isinstance(params, dict) else params:\n        if k in collection_formats:\n            collection_format = collection_formats[k]\n            if collection_format == 'multi':\n                new_params.extend((k, value) for value in v)\n            else:\n                if collection_format == 'ssv':\n                    delimiter = ' '\n                elif collection_format == 'tsv':\n                    delimiter = '\\t'\n                elif collection_format == 'pipes':\n                    delimiter = '|'\n                else:  # csv is the default\n                    delimiter = ','\n                new_params.append(\n                    (k, delimiter.join(str(value) for value in v)))\n        else:\n            new_params.append((k, v))\n    return new_params\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.parameters_to_url_query","title":"<code>parameters_to_url_query(params, collection_formats)</code>","text":"<p>Get parameters as list of tuples, formatting collections.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <p>Parameters as dict or list of two-tuples</p> required <code>collection_formats</code> <code>dict</code> <p>Parameter collection formats</p> required <p>Returns:</p> Type Description <p>URL query string (e.g. a=Hello%20World&amp;b=123)</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def parameters_to_url_query(self, params, collection_formats):\n    \"\"\"Get parameters as list of tuples, formatting collections.\n\n    :param params: Parameters as dict or list of two-tuples\n    :param dict collection_formats: Parameter collection formats\n    :return: URL query string (e.g. a=Hello%20World&amp;b=123)\n    \"\"\"\n    new_params = []\n    if collection_formats is None:\n        collection_formats = {}\n    for k, v in params.items() if isinstance(params, dict) else params:\n        if isinstance(v, bool):\n            v = str(v).lower()\n        if isinstance(v, (int, float)):\n            v = str(v)\n        if isinstance(v, dict):\n            v = json.dumps(v)\n\n        if k in collection_formats:\n            collection_format = collection_formats[k]\n            if collection_format == 'multi':\n                new_params.extend((k, value) for value in v)\n            else:\n                if collection_format == 'ssv':\n                    delimiter = ' '\n                elif collection_format == 'tsv':\n                    delimiter = '\\t'\n                elif collection_format == 'pipes':\n                    delimiter = '|'\n                else:  # csv is the default\n                    delimiter = ','\n                new_params.append(\n                    (k, delimiter.join(quote(str(value)) for value in v))\n                )\n        else:\n            new_params.append((k, quote(str(v))))\n\n    return \"&amp;\".join([\"=\".join(item) for item in new_params])\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.response_deserialize","title":"<code>response_deserialize(response_data=None, response_types_map=None)</code>","text":"<p>Deserializes response into an object.</p> <p>Parameters:</p> Name Type Description Default <code>response_data</code> <p>RESTResponse object to be deserialized.</p> <code>None</code> <code>response_types_map</code> <p>dict of response types.</p> <code>None</code> <p>Returns:</p> Type Description <code>ApiResponse</code> <p>ApiResponse</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def response_deserialize(\n    self,\n    response_data=None,\n    response_types_map=None\n) -&gt; ApiResponse:\n    \"\"\"Deserializes response into an object.\n    :param response_data: RESTResponse object to be deserialized.\n    :param response_types_map: dict of response types.\n    :return: ApiResponse\n    \"\"\"\n\n\n    response_type = response_types_map.get(str(response_data.status), None)\n    if not response_type and isinstance(response_data.status, int) and 100 &lt;= response_data.status &lt;= 599:\n        # if not found, look for '1XX', '2XX', etc.\n        response_type = response_types_map.get(str(response_data.status)[0] + \"XX\", None)\n\n    if not 200 &lt;= response_data.status &lt;= 299:\n        if response_data.status == 400:\n            raise BadRequestException(http_resp=response_data)\n\n        if response_data.status == 401:\n            raise UnauthorizedException(http_resp=response_data)\n\n        if response_data.status == 403:\n            raise ForbiddenException(http_resp=response_data)\n\n        if response_data.status == 404:\n            raise NotFoundException(http_resp=response_data)\n\n        if 500 &lt;= response_data.status &lt;= 599:\n            raise ServiceException(http_resp=response_data)\n        raise ApiException(http_resp=response_data)\n\n    # deserialize response data\n\n    if response_type == \"bytearray\":\n        return_data = response_data.data\n    elif response_type is None:\n        return_data = None\n    elif response_type == \"file\":\n        return_data = self.__deserialize_file(response_data)\n    else:\n        match = None\n        content_type = response_data.getheader('content-type')\n        if content_type is not None:\n            match = re.search(r\"charset=([a-zA-Z\\-\\d]+)[\\s;]?\", content_type)\n        encoding = match.group(1) if match else \"utf-8\"\n        response_text = response_data.data.decode(encoding)\n        return_data = self.deserialize(response_text, response_type)\n\n    return ApiResponse(\n        status_code = response_data.status,\n        data = return_data,\n        headers = response_data.getheaders(),\n        raw_data = response_data.data\n    )\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.sanitize_for_serialization","title":"<code>sanitize_for_serialization(obj)</code>","text":"<p>Builds a JSON POST object.</p> <p>If obj is None, return None. If obj is str, int, long, float, bool, return directly. If obj is datetime.datetime, datetime.date     convert to string in iso8601 format. If obj is list, sanitize each element in the list. If obj is dict, return the dict. If obj is OpenAPI model, return the properties dict.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>The data to serialize.</p> required <p>Returns:</p> Type Description <p>The serialized form of data.</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def sanitize_for_serialization(self, obj):\n    \"\"\"Builds a JSON POST object.\n\n    If obj is None, return None.\n    If obj is str, int, long, float, bool, return directly.\n    If obj is datetime.datetime, datetime.date\n        convert to string in iso8601 format.\n    If obj is list, sanitize each element in the list.\n    If obj is dict, return the dict.\n    If obj is OpenAPI model, return the properties dict.\n\n    :param obj: The data to serialize.\n    :return: The serialized form of data.\n    \"\"\"\n    if obj is None:\n        return None\n    elif isinstance(obj, self.PRIMITIVE_TYPES):\n        return obj\n    elif isinstance(obj, list):\n        return [\n            self.sanitize_for_serialization(sub_obj) for sub_obj in obj\n        ]\n    elif isinstance(obj, tuple):\n        return tuple(\n            self.sanitize_for_serialization(sub_obj) for sub_obj in obj\n        )\n    elif isinstance(obj, (datetime.datetime, datetime.date)):\n        return obj.isoformat()\n\n    elif isinstance(obj, dict):\n        obj_dict = obj\n    else:\n        # Convert model obj to dict except\n        # attributes `openapi_types`, `attribute_map`\n        # and attributes which value is not None.\n        # Convert attribute name to json key in\n        # model definition for request.\n        obj_dict = obj.to_dict()\n\n    return {\n        key: self.sanitize_for_serialization(val)\n        for key, val in obj_dict.items()\n    }\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.select_header_accept","title":"<code>select_header_accept(accepts)</code>","text":"<p>Returns <code>Accept</code> based on an array of accepts provided.</p> <p>Parameters:</p> Name Type Description Default <code>accepts</code> <code>List[str]</code> <p>List of headers.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Accept (e.g. application/json).</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def select_header_accept(self, accepts: List[str]) -&gt; Optional[str]:\n    \"\"\"Returns `Accept` based on an array of accepts provided.\n\n    :param accepts: List of headers.\n    :return: Accept (e.g. application/json).\n    \"\"\"\n    if not accepts:\n        return None\n\n    for accept in accepts:\n        if re.search('json', accept, re.IGNORECASE):\n            return accept\n\n    return accepts[0]\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.select_header_content_type","title":"<code>select_header_content_type(content_types)</code>","text":"<p>Returns <code>Content-Type</code> based on an array of content_types provided.</p> <p>Parameters:</p> Name Type Description Default <code>content_types</code> <p>List of content-types.</p> required <p>Returns:</p> Type Description <p>Content-Type (e.g. application/json).</p> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def select_header_content_type(self, content_types):\n    \"\"\"Returns `Content-Type` based on an array of content_types provided.\n\n    :param content_types: List of content-types.\n    :return: Content-Type (e.g. application/json).\n    \"\"\"\n    if not content_types:\n        return None\n\n    for content_type in content_types:\n        if re.search('json', content_type, re.IGNORECASE):\n            return content_type\n\n    return content_types[0]\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.set_default","title":"<code>set_default(default)</code>  <code>classmethod</code>","text":"<p>Set default instance of ApiClient.</p> <p>It stores default ApiClient.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <p>object of ApiClient.</p> required Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>@classmethod\ndef set_default(cls, default):\n    \"\"\"Set default instance of ApiClient.\n\n    It stores default ApiClient.\n\n    :param default: object of ApiClient.\n    \"\"\"\n    cls._default = default\n</code></pre>"},{"location":"API_Documentation/api_client/#cheshire_cat_api.api_client.ApiClient.update_params_for_auth","title":"<code>update_params_for_auth(headers, queries, auth_settings, resource_path, method, body, request_auth=None)</code>","text":"<p>Updates header and query params based on authentication setting.</p> <p>:resource_path: A string representation of the HTTP request resource path. :method: A string representation of the HTTP request method. :body: A object representing the body of the HTTP request. The object type is the return value of sanitize_for_serialization().</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <p>Header parameters dict to be updated.</p> required <code>queries</code> <p>Query parameters tuple list to be updated.</p> required <code>auth_settings</code> <p>Authentication setting identifiers list.</p> required <code>request_auth</code> <p>if set, the provided settings will override the token in the configuration.</p> <code>None</code> Source code in <code>cheshire_cat_api/api_client.py</code> <pre><code>def update_params_for_auth(\n    self,\n    headers,\n    queries,\n    auth_settings,\n    resource_path,\n    method,\n    body,\n    request_auth=None\n) -&gt; None:\n    \"\"\"Updates header and query params based on authentication setting.\n\n    :param headers: Header parameters dict to be updated.\n    :param queries: Query parameters tuple list to be updated.\n    :param auth_settings: Authentication setting identifiers list.\n    :resource_path: A string representation of the HTTP request resource path.\n    :method: A string representation of the HTTP request method.\n    :body: A object representing the body of the HTTP request.\n    The object type is the return value of sanitize_for_serialization().\n    :param request_auth: if set, the provided settings will\n                         override the token in the configuration.\n    \"\"\"\n    if not auth_settings:\n        return\n\n    if request_auth:\n        self._apply_auth_params(\n            headers,\n            queries,\n            resource_path,\n            method,\n            body,\n            request_auth\n        )\n    else:\n        for auth in auth_settings:\n            auth_setting = self.configuration.auth_settings().get(auth)\n            if auth_setting:\n                self._apply_auth_params(\n                    headers,\n                    queries,\n                    resource_path,\n                    method,\n                    body,\n                    auth_setting\n                )\n</code></pre>"},{"location":"API_Documentation/api_response/","title":"api_response","text":"<p>API response object.</p>"},{"location":"API_Documentation/api_response/#cheshire_cat_api.api_response.ApiResponse","title":"<code>ApiResponse</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>API response object</p> Source code in <code>cheshire_cat_api/api_response.py</code> <pre><code>class ApiResponse(BaseModel, Generic[T]):\n    \"\"\"\n    API response object\n    \"\"\"\n\n    status_code: StrictInt = Field(description=\"HTTP status code\")\n    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description=\"HTTP headers\")\n    data: T = Field(description=\"Deserialized data given the data type\")\n    raw_data: StrictBytes = Field(description=\"Raw data (HTTP response body)\")\n\n    model_config = {\n        \"arbitrary_types_allowed\": True\n    }\n</code></pre>"},{"location":"API_Documentation/cat_client/","title":"cat_client","text":""},{"location":"API_Documentation/cat_client/#cheshire_cat_api.cat_client.CatClient","title":"<code>CatClient</code>","text":"<p>The class to communicate with the Cheshire Cat AI</p> Source code in <code>cheshire_cat_api/cat_client.py</code> <pre><code>class CatClient:\n    \"\"\"\n    The class to communicate with the Cheshire Cat AI\n    \"\"\"\n\n    def __init__(self,\n                 config: Optional[Config] = None,\n                 on_open: Optional[Callable] = None,\n                 on_close: Optional[Callable] = None,\n                 on_message: Optional[Callable] = None,\n                 on_error: Optional[Callable] = None\n                 ):\n\n        # Instantiate user message handlers if any, otherwise use default\n        self.on_message = on_message\n        self.on_error = on_error\n        self.on_close = on_close\n        self.on_open = on_open\n\n        # Settings\n        self._conn_settings = config if config is not None else Config()\n        # TODO: user_id should be automatically passed from settings to http endpoints\n\n        self.memory = None\n        self.plugins = None\n        self.rabbit_hole = None\n        self.status = None\n        self.embedder = None\n        self.settings = None\n        self.llm = None\n\n        self._ws = None\n\n        self._connect_api()\n\n    def _connect_api(self):\n        protocol = \"https\" if self._conn_settings.secure_connection else \"http\"\n        config = Configuration(host=f\"{protocol}://{self._conn_settings.base_url}:{self._conn_settings.port}\")\n\n        client = ApiClient(\n            configuration=config,\n            header_name='access_token',\n            header_value=self._conn_settings.auth_key\n        )\n        self.memory = MemoryApi(client)\n        self.plugins = PluginsApi(client)\n        self.rabbit_hole = RabbitHoleApi(client)\n        self.status = StatusApi(client)\n        self.embedder = EmbedderApi(client)\n        self.settings = SettingsApi(client)\n        self.llm = LargeLanguageModelApi(client)\n\n    def connect_ws(self):\n        protocol = \"wss\" if self._conn_settings.secure_connection else \"ws\"\n        url = f\"{protocol}://{self._conn_settings.base_url}:{self._conn_settings.port}/ws/{self._conn_settings.user_id}\"\n        if self._conn_settings.auth_key:\n            url += f\"?token={self._conn_settings.auth_key}\"\n\n        self._ws = WebSocketApp(\n            url,\n            on_message=self.on_ws_message,\n            on_error=self.on_ws_error,\n            on_close=self.on_ws_close,\n            on_open=self.on_ws_open\n        )\n\n        self.conn = Thread(target=self._ws.run_forever)\n        self.conn.start()\n\n    def on_ws_open(self, ws):\n        \"\"\"\"Default message handler on connection opening\"\"\"\n\n        logging.info(f\"Websocket connection established with id {self._conn_settings.user_id}\")\n\n        # Run user custom function\n        if callable(self.on_open):\n            self.on_open()\n\n    def on_ws_message(self, ws, message: str):\n        \"\"\"\"Default message handler when receiving a message\"\"\"\n        # Run user custom function\n        if callable(self.on_message):\n            self.on_message(message)\n            return\n\n        answer = json.loads(message)\n        print(answer[\"content\"])\n\n    def on_ws_error(self, ws, error: Exception):\n        \"\"\"\"Default message handler on WebSocket error\"\"\"\n\n        logging.exception(f\"An error occurred in ws connection with id {self._conn_settings.user_id}: {error}\", exc_info=True)\n\n        # Run user custom function\n        if callable(self.on_error):\n            self.on_error(error)\n\n    def on_ws_close(self, ws, status_code: int, msg: str):\n        \"\"\"\"Default message handler on closed connection\"\"\"\n\n        logging.info(f\"Connection with id {self._conn_settings.user_id} closed with code {status_code}: {msg}\")\n\n        # Run user custom function\n        if callable(self.on_close):\n            self.on_close(status_code, msg)\n\n\n    def send(self, message: str, **kwargs):\n        \"\"\"Send a message to WebSocket server using a separate thread\"\"\"\n\n        if self._ws is None:     \n            logging.warning(\"WebSocket connection is not available. Message not sent.\")\n        else:\n            self._ws.send(json.dumps({\n                \"text\": message,\n                **kwargs\n            }))\n\n    def close(self):\n\n        if self._ws is None:\n            logging.warning(\"Websocket connection is already close\")\n            return\n\n        # Close connection\n        self._ws.close()\n        self.conn.join()\n\n    @property\n    def is_ws_connected(self):\n        return self._ws and self._ws.sock and self._ws.sock.connected\n</code></pre>"},{"location":"API_Documentation/cat_client/#cheshire_cat_api.cat_client.CatClient.on_ws_close","title":"<code>on_ws_close(ws, status_code, msg)</code>","text":"<p>\"Default message handler on closed connection</p> Source code in <code>cheshire_cat_api/cat_client.py</code> <pre><code>def on_ws_close(self, ws, status_code: int, msg: str):\n    \"\"\"\"Default message handler on closed connection\"\"\"\n\n    logging.info(f\"Connection with id {self._conn_settings.user_id} closed with code {status_code}: {msg}\")\n\n    # Run user custom function\n    if callable(self.on_close):\n        self.on_close(status_code, msg)\n</code></pre>"},{"location":"API_Documentation/cat_client/#cheshire_cat_api.cat_client.CatClient.on_ws_error","title":"<code>on_ws_error(ws, error)</code>","text":"<p>\"Default message handler on WebSocket error</p> Source code in <code>cheshire_cat_api/cat_client.py</code> <pre><code>def on_ws_error(self, ws, error: Exception):\n    \"\"\"\"Default message handler on WebSocket error\"\"\"\n\n    logging.exception(f\"An error occurred in ws connection with id {self._conn_settings.user_id}: {error}\", exc_info=True)\n\n    # Run user custom function\n    if callable(self.on_error):\n        self.on_error(error)\n</code></pre>"},{"location":"API_Documentation/cat_client/#cheshire_cat_api.cat_client.CatClient.on_ws_message","title":"<code>on_ws_message(ws, message)</code>","text":"<p>\"Default message handler when receiving a message</p> Source code in <code>cheshire_cat_api/cat_client.py</code> <pre><code>def on_ws_message(self, ws, message: str):\n    \"\"\"\"Default message handler when receiving a message\"\"\"\n    # Run user custom function\n    if callable(self.on_message):\n        self.on_message(message)\n        return\n\n    answer = json.loads(message)\n    print(answer[\"content\"])\n</code></pre>"},{"location":"API_Documentation/cat_client/#cheshire_cat_api.cat_client.CatClient.on_ws_open","title":"<code>on_ws_open(ws)</code>","text":"<p>\"Default message handler on connection opening</p> Source code in <code>cheshire_cat_api/cat_client.py</code> <pre><code>def on_ws_open(self, ws):\n    \"\"\"\"Default message handler on connection opening\"\"\"\n\n    logging.info(f\"Websocket connection established with id {self._conn_settings.user_id}\")\n\n    # Run user custom function\n    if callable(self.on_open):\n        self.on_open()\n</code></pre>"},{"location":"API_Documentation/cat_client/#cheshire_cat_api.cat_client.CatClient.send","title":"<code>send(message, **kwargs)</code>","text":"<p>Send a message to WebSocket server using a separate thread</p> Source code in <code>cheshire_cat_api/cat_client.py</code> <pre><code>def send(self, message: str, **kwargs):\n    \"\"\"Send a message to WebSocket server using a separate thread\"\"\"\n\n    if self._ws is None:     \n        logging.warning(\"WebSocket connection is not available. Message not sent.\")\n    else:\n        self._ws.send(json.dumps({\n            \"text\": message,\n            **kwargs\n        }))\n</code></pre>"},{"location":"API_Documentation/config/","title":"config","text":""},{"location":"API_Documentation/config/#cheshire_cat_api.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Class containing all the configuration options and variables used by ccat-api package</p> Source code in <code>cheshire_cat_api/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Class containing all the configuration options and variables used by ccat-api package\n    \"\"\"  \n    base_url: str = 'localhost'\n    port: int = 1865\n    user_id: str = \"user\"\n    auth_key: str = ''\n    secure_connection: bool = False\n</code></pre>"},{"location":"API_Documentation/configuration/","title":"configuration","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration","title":"<code>Configuration</code>","text":"<p>This class contains various settings of the API client.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <p>Base url.</p> <code>None</code> <code>api_key</code> <p>Dict to store API key(s). Each entry in the dict specifies an API key. The dict key is the name of the security scheme in the OAS specification. The dict value is the API key secret.</p> <code>None</code> <code>api_key_prefix</code> <p>Dict to store API prefix (e.g. Bearer). The dict key is the name of the security scheme in the OAS specification. The dict value is an API key prefix when generating the auth data.</p> <code>None</code> <code>username</code> <p>Username for HTTP basic authentication.</p> <code>None</code> <code>password</code> <p>Password for HTTP basic authentication.</p> <code>None</code> <code>access_token</code> <p>Access token.</p> <code>None</code> <code>server_index</code> <p>Index to servers configuration.</p> <code>None</code> <code>server_variables</code> <p>Mapping with string values to replace variables in templated server configuration. The validation of enums is performed for variables with defined enum values before.</p> <code>None</code> <code>server_operation_index</code> <p>Mapping from operation ID to an index to server configuration.</p> <code>None</code> <code>server_operation_variables</code> <p>Mapping from operation ID to a mapping with string values to replace variables in templated server configuration. The validation of enums is performed for variables with defined enum values before.</p> <code>None</code> <code>ssl_ca_cert</code> <p>str - the path to a file of concatenated CA certificates in PEM format.</p> <code>None</code> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>class Configuration:\n    \"\"\"This class contains various settings of the API client.\n\n    :param host: Base url.\n    :param api_key: Dict to store API key(s).\n      Each entry in the dict specifies an API key.\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is the API key secret.\n    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).\n      The dict key is the name of the security scheme in the OAS specification.\n      The dict value is an API key prefix when generating the auth data.\n    :param username: Username for HTTP basic authentication.\n    :param password: Password for HTTP basic authentication.\n    :param access_token: Access token.\n    :param server_index: Index to servers configuration.\n    :param server_variables: Mapping with string values to replace variables in\n      templated server configuration. The validation of enums is performed for\n      variables with defined enum values before.\n    :param server_operation_index: Mapping from operation ID to an index to server\n      configuration.\n    :param server_operation_variables: Mapping from operation ID to a mapping with\n      string values to replace variables in templated server configuration.\n      The validation of enums is performed for variables with defined enum\n      values before.\n    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates\n      in PEM format.\n\n    \"\"\"\n\n    _default = None\n\n    def __init__(self, host=None,\n                 api_key=None, api_key_prefix=None,\n                 username=None, password=None,\n                 access_token=None,\n                 server_index=None, server_variables=None,\n                 server_operation_index=None, server_operation_variables=None,\n                 ssl_ca_cert=None,\n                 ) -&gt; None:\n        \"\"\"Constructor\n        \"\"\"\n        self._base_path = \"http://localhost\" if host is None else host\n        \"\"\"Default Base url\n        \"\"\"\n        self.server_index = 0 if server_index is None and host is None else server_index\n        self.server_operation_index = server_operation_index or {}\n        \"\"\"Default server index\n        \"\"\"\n        self.server_variables = server_variables or {}\n        self.server_operation_variables = server_operation_variables or {}\n        \"\"\"Default server variables\n        \"\"\"\n        self.temp_folder_path = None\n        \"\"\"Temp file folder for downloading files\n        \"\"\"\n        # Authentication Settings\n        self.api_key = {}\n        if api_key:\n            self.api_key = api_key\n        \"\"\"dict to store API key(s)\n        \"\"\"\n        self.api_key_prefix = {}\n        if api_key_prefix:\n            self.api_key_prefix = api_key_prefix\n        \"\"\"dict to store API prefix (e.g. Bearer)\n        \"\"\"\n        self.refresh_api_key_hook = None\n        \"\"\"function hook to refresh API key if expired\n        \"\"\"\n        self.username = username\n        \"\"\"Username for HTTP basic authentication\n        \"\"\"\n        self.password = password\n        \"\"\"Password for HTTP basic authentication\n        \"\"\"\n        self.access_token = access_token\n        \"\"\"Access token\n        \"\"\"\n        self.logger = {}\n        \"\"\"Logging Settings\n        \"\"\"\n        self.logger[\"package_logger\"] = logging.getLogger(\"cheshire_cat_api\")\n        self.logger[\"urllib3_logger\"] = logging.getLogger(\"urllib3\")\n        self.logger_format = '%(asctime)s %(levelname)s %(message)s'\n        \"\"\"Log format\n        \"\"\"\n        self.logger_stream_handler = None\n        \"\"\"Log stream handler\n        \"\"\"\n        self.logger_file_handler = None\n        \"\"\"Log file handler\n        \"\"\"\n        self.logger_file = None\n        \"\"\"Debug file location\n        \"\"\"\n        self.debug = False\n        \"\"\"Debug switch\n        \"\"\"\n\n        self.verify_ssl = True\n        \"\"\"SSL/TLS verification\n           Set this to false to skip verifying SSL certificate when calling API\n           from https server.\n        \"\"\"\n        self.ssl_ca_cert = ssl_ca_cert\n        \"\"\"Set this to customize the certificate file to verify the peer.\n        \"\"\"\n        self.cert_file = None\n        \"\"\"client certificate file\n        \"\"\"\n        self.key_file = None\n        \"\"\"client key file\n        \"\"\"\n        self.assert_hostname = None\n        \"\"\"Set this to True/False to enable/disable SSL hostname verification.\n        \"\"\"\n        self.tls_server_name = None\n        \"\"\"SSL/TLS Server Name Indication (SNI)\n           Set this to the SNI value expected by the server.\n        \"\"\"\n\n\n        self.proxy = None\n        \"\"\"Proxy URL\n        \"\"\"\n        self.proxy_headers = None\n        \"\"\"Proxy headers\n        \"\"\"\n        self.safe_chars_for_path_param = ''\n        \"\"\"Safe chars for path_param\n        \"\"\"\n        self.retries = None\n        \"\"\"Adding retries to override urllib3 default value 3\n        \"\"\"\n        # Enable client side validation\n        self.client_side_validation = True\n\n        self.socket_options = None\n        \"\"\"Options to pass down to the underlying urllib3 socket\n        \"\"\"\n\n        self.datetime_format = \"%Y-%m-%dT%H:%M:%S.%f%z\"\n        \"\"\"datetime format\n        \"\"\"\n\n        self.date_format = \"%Y-%m-%d\"\n        \"\"\"date format\n        \"\"\"\n\n    def __deepcopy__(self, memo):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        memo[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k not in ('logger', 'logger_file_handler'):\n                setattr(result, k, copy.deepcopy(v, memo))\n        # shallow copy of loggers\n        result.logger = copy.copy(self.logger)\n        # use setters to configure loggers\n        result.logger_file = self.logger_file\n        result.debug = self.debug\n        return result\n\n    def __setattr__(self, name, value):\n        object.__setattr__(self, name, value)\n\n    @classmethod\n    def set_default(cls, default):\n        \"\"\"Set default instance of configuration.\n\n        It stores default configuration, which can be\n        returned by get_default_copy method.\n\n        :param default: object of Configuration\n        \"\"\"\n        cls._default = default\n\n    @classmethod\n    def get_default_copy(cls):\n        \"\"\"Deprecated. Please use `get_default` instead.\n\n        Deprecated. Please use `get_default` instead.\n\n        :return: The configuration object.\n        \"\"\"\n        return cls.get_default()\n\n    @classmethod\n    def get_default(cls):\n        \"\"\"Return the default configuration.\n\n        This method returns newly created, based on default constructor,\n        object of Configuration class or returns a copy of default\n        configuration.\n\n        :return: The configuration object.\n        \"\"\"\n        if cls._default is None:\n            cls._default = Configuration()\n        return cls._default\n\n    @property\n    def logger_file(self):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        return self.__logger_file\n\n    @logger_file.setter\n    def logger_file(self, value):\n        \"\"\"The logger file.\n\n        If the logger_file is None, then add stream handler and remove file\n        handler. Otherwise, add file handler and remove stream handler.\n\n        :param value: The logger_file path.\n        :type: str\n        \"\"\"\n        self.__logger_file = value\n        if self.__logger_file:\n            # If set logging file,\n            # then add file handler and remove stream handler.\n            self.logger_file_handler = logging.FileHandler(self.__logger_file)\n            self.logger_file_handler.setFormatter(self.logger_formatter)\n            for _, logger in self.logger.items():\n                logger.addHandler(self.logger_file_handler)\n\n    @property\n    def debug(self):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        return self.__debug\n\n    @debug.setter\n    def debug(self, value):\n        \"\"\"Debug status\n\n        :param value: The debug status, True or False.\n        :type: bool\n        \"\"\"\n        self.__debug = value\n        if self.__debug:\n            # if debug status is True, turn on debug logging\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.DEBUG)\n            # turn on httplib debug\n            httplib.HTTPConnection.debuglevel = 1\n        else:\n            # if debug status is False, turn off debug logging,\n            # setting log level to default `logging.WARNING`\n            for _, logger in self.logger.items():\n                logger.setLevel(logging.WARNING)\n            # turn off httplib debug\n            httplib.HTTPConnection.debuglevel = 0\n\n    @property\n    def logger_format(self):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        return self.__logger_format\n\n    @logger_format.setter\n    def logger_format(self, value):\n        \"\"\"The logger format.\n\n        The logger_formatter will be updated when sets logger_format.\n\n        :param value: The format string.\n        :type: str\n        \"\"\"\n        self.__logger_format = value\n        self.logger_formatter = logging.Formatter(self.__logger_format)\n\n    def get_api_key_with_prefix(self, identifier, alias=None):\n        \"\"\"Gets API key (with prefix if set).\n\n        :param identifier: The identifier of apiKey.\n        :param alias: The alternative identifier of apiKey.\n        :return: The token for api key authentication.\n        \"\"\"\n        if self.refresh_api_key_hook is not None:\n            self.refresh_api_key_hook(self)\n        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)\n        if key:\n            prefix = self.api_key_prefix.get(identifier)\n            if prefix:\n                return \"%s %s\" % (prefix, key)\n            else:\n                return key\n\n    def get_basic_auth_token(self):\n        \"\"\"Gets HTTP basic authentication header (string).\n\n        :return: The token for basic HTTP authentication.\n        \"\"\"\n        username = \"\"\n        if self.username is not None:\n            username = self.username\n        password = \"\"\n        if self.password is not None:\n            password = self.password\n        return urllib3.util.make_headers(\n            basic_auth=username + ':' + password\n        ).get('authorization')\n\n    def auth_settings(self):\n        \"\"\"Gets Auth Settings dict for api client.\n\n        :return: The Auth Settings information dict.\n        \"\"\"\n        auth = {}\n        return auth\n\n    def to_debug_report(self):\n        \"\"\"Gets the essential information for debugging.\n\n        :return: The report for debugging.\n        \"\"\"\n        return \"Python SDK Debug Report:\\n\"\\\n               \"OS: {env}\\n\"\\\n               \"Python Version: {pyversion}\\n\"\\\n               \"Version of the API: 1.3.1\\n\"\\\n               \"SDK Package Version: 1.0.0\".\\\n               format(env=sys.platform, pyversion=sys.version)\n\n    def get_host_settings(self):\n        \"\"\"Gets an array of host settings\n\n        :return: An array of host settings\n        \"\"\"\n        return [\n            {\n                'url': \"\",\n                'description': \"No description provided\",\n            }\n        ]\n\n    def get_host_from_settings(self, index, variables=None, servers=None):\n        \"\"\"Gets host URL based on the index and variables\n        :param index: array index of the host settings\n        :param variables: hash of variable and the corresponding value\n        :param servers: an array of host settings or None\n        :return: URL based on host settings\n        \"\"\"\n        if index is None:\n            return self._base_path\n\n        variables = {} if variables is None else variables\n        servers = self.get_host_settings() if servers is None else servers\n\n        try:\n            server = servers[index]\n        except IndexError:\n            raise ValueError(\n                \"Invalid index {0} when selecting the host settings. \"\n                \"Must be less than {1}\".format(index, len(servers)))\n\n        url = server['url']\n\n        # go through variables and replace placeholders\n        for variable_name, variable in server.get('variables', {}).items():\n            used_value = variables.get(\n                variable_name, variable['default_value'])\n\n            if 'enum_values' in variable \\\n                    and used_value not in variable['enum_values']:\n                raise ValueError(\n                    \"The variable `{0}` in the host URL has invalid value \"\n                    \"{1}. Must be {2}.\".format(\n                        variable_name, variables[variable_name],\n                        variable['enum_values']))\n\n            url = url.replace(\"{\" + variable_name + \"}\", used_value)\n\n        return url\n\n    @property\n    def host(self):\n        \"\"\"Return generated host.\"\"\"\n        return self.get_host_from_settings(self.server_index, variables=self.server_variables)\n\n    @host.setter\n    def host(self, value):\n        \"\"\"Fix base path.\"\"\"\n        self._base_path = value\n        self.server_index = None\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration._base_path","title":"<code>_base_path = 'http://localhost' if host is None else host</code>  <code>instance-attribute</code>","text":"<p>Default Base url</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.access_token","title":"<code>access_token = access_token</code>  <code>instance-attribute</code>","text":"<p>Access token</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.assert_hostname","title":"<code>assert_hostname = None</code>  <code>instance-attribute</code>","text":"<p>Set this to True/False to enable/disable SSL hostname verification.</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.cert_file","title":"<code>cert_file = None</code>  <code>instance-attribute</code>","text":"<p>client certificate file</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.date_format","title":"<code>date_format = '%Y-%m-%d'</code>  <code>instance-attribute</code>","text":"<p>date format</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.datetime_format","title":"<code>datetime_format = '%Y-%m-%dT%H:%M:%S.%f%z'</code>  <code>instance-attribute</code>","text":"<p>datetime format</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.debug","title":"<code>debug</code>  <code>property</code> <code>writable</code>","text":"<p>Debug status</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The debug status, True or False.</p> required"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.host","title":"<code>host</code>  <code>property</code> <code>writable</code>","text":"<p>Return generated host.</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.key_file","title":"<code>key_file = None</code>  <code>instance-attribute</code>","text":"<p>client key file</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.logger","title":"<code>logger = {}</code>  <code>instance-attribute</code>","text":"<p>Logging Settings</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.logger_file","title":"<code>logger_file</code>  <code>property</code> <code>writable</code>","text":"<p>The logger file.</p> <p>If the logger_file is None, then add stream handler and remove file handler. Otherwise, add file handler and remove stream handler.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The logger_file path.</p> required"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.logger_file_handler","title":"<code>logger_file_handler = None</code>  <code>instance-attribute</code>","text":"<p>Log file handler</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.logger_format","title":"<code>logger_format</code>  <code>property</code> <code>writable</code>","text":"<p>The logger format.</p> <p>The logger_formatter will be updated when sets logger_format.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The format string.</p> required"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.logger_stream_handler","title":"<code>logger_stream_handler = None</code>  <code>instance-attribute</code>","text":"<p>Log stream handler</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.password","title":"<code>password = password</code>  <code>instance-attribute</code>","text":"<p>Password for HTTP basic authentication</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.proxy","title":"<code>proxy = None</code>  <code>instance-attribute</code>","text":"<p>Proxy URL</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.proxy_headers","title":"<code>proxy_headers = None</code>  <code>instance-attribute</code>","text":"<p>Proxy headers</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.refresh_api_key_hook","title":"<code>refresh_api_key_hook = None</code>  <code>instance-attribute</code>","text":"<p>function hook to refresh API key if expired</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.retries","title":"<code>retries = None</code>  <code>instance-attribute</code>","text":"<p>Adding retries to override urllib3 default value 3</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.safe_chars_for_path_param","title":"<code>safe_chars_for_path_param = ''</code>  <code>instance-attribute</code>","text":"<p>Safe chars for path_param</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.server_operation_index","title":"<code>server_operation_index = server_operation_index or {}</code>  <code>instance-attribute</code>","text":"<p>Default server index</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.server_operation_variables","title":"<code>server_operation_variables = server_operation_variables or {}</code>  <code>instance-attribute</code>","text":"<p>Default server variables</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.socket_options","title":"<code>socket_options = None</code>  <code>instance-attribute</code>","text":"<p>Options to pass down to the underlying urllib3 socket</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.ssl_ca_cert","title":"<code>ssl_ca_cert = ssl_ca_cert</code>  <code>instance-attribute</code>","text":"<p>Set this to customize the certificate file to verify the peer.</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.temp_folder_path","title":"<code>temp_folder_path = None</code>  <code>instance-attribute</code>","text":"<p>Temp file folder for downloading files</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.tls_server_name","title":"<code>tls_server_name = None</code>  <code>instance-attribute</code>","text":"<p>SSL/TLS Server Name Indication (SNI) Set this to the SNI value expected by the server.</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.username","title":"<code>username = username</code>  <code>instance-attribute</code>","text":"<p>Username for HTTP basic authentication</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.verify_ssl","title":"<code>verify_ssl = True</code>  <code>instance-attribute</code>","text":"<p>SSL/TLS verification Set this to false to skip verifying SSL certificate when calling API from https server.</p>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.__init__","title":"<code>__init__(host=None, api_key=None, api_key_prefix=None, username=None, password=None, access_token=None, server_index=None, server_variables=None, server_operation_index=None, server_operation_variables=None, ssl_ca_cert=None)</code>","text":"<p>Constructor</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>def __init__(self, host=None,\n             api_key=None, api_key_prefix=None,\n             username=None, password=None,\n             access_token=None,\n             server_index=None, server_variables=None,\n             server_operation_index=None, server_operation_variables=None,\n             ssl_ca_cert=None,\n             ) -&gt; None:\n    \"\"\"Constructor\n    \"\"\"\n    self._base_path = \"http://localhost\" if host is None else host\n    \"\"\"Default Base url\n    \"\"\"\n    self.server_index = 0 if server_index is None and host is None else server_index\n    self.server_operation_index = server_operation_index or {}\n    \"\"\"Default server index\n    \"\"\"\n    self.server_variables = server_variables or {}\n    self.server_operation_variables = server_operation_variables or {}\n    \"\"\"Default server variables\n    \"\"\"\n    self.temp_folder_path = None\n    \"\"\"Temp file folder for downloading files\n    \"\"\"\n    # Authentication Settings\n    self.api_key = {}\n    if api_key:\n        self.api_key = api_key\n    \"\"\"dict to store API key(s)\n    \"\"\"\n    self.api_key_prefix = {}\n    if api_key_prefix:\n        self.api_key_prefix = api_key_prefix\n    \"\"\"dict to store API prefix (e.g. Bearer)\n    \"\"\"\n    self.refresh_api_key_hook = None\n    \"\"\"function hook to refresh API key if expired\n    \"\"\"\n    self.username = username\n    \"\"\"Username for HTTP basic authentication\n    \"\"\"\n    self.password = password\n    \"\"\"Password for HTTP basic authentication\n    \"\"\"\n    self.access_token = access_token\n    \"\"\"Access token\n    \"\"\"\n    self.logger = {}\n    \"\"\"Logging Settings\n    \"\"\"\n    self.logger[\"package_logger\"] = logging.getLogger(\"cheshire_cat_api\")\n    self.logger[\"urllib3_logger\"] = logging.getLogger(\"urllib3\")\n    self.logger_format = '%(asctime)s %(levelname)s %(message)s'\n    \"\"\"Log format\n    \"\"\"\n    self.logger_stream_handler = None\n    \"\"\"Log stream handler\n    \"\"\"\n    self.logger_file_handler = None\n    \"\"\"Log file handler\n    \"\"\"\n    self.logger_file = None\n    \"\"\"Debug file location\n    \"\"\"\n    self.debug = False\n    \"\"\"Debug switch\n    \"\"\"\n\n    self.verify_ssl = True\n    \"\"\"SSL/TLS verification\n       Set this to false to skip verifying SSL certificate when calling API\n       from https server.\n    \"\"\"\n    self.ssl_ca_cert = ssl_ca_cert\n    \"\"\"Set this to customize the certificate file to verify the peer.\n    \"\"\"\n    self.cert_file = None\n    \"\"\"client certificate file\n    \"\"\"\n    self.key_file = None\n    \"\"\"client key file\n    \"\"\"\n    self.assert_hostname = None\n    \"\"\"Set this to True/False to enable/disable SSL hostname verification.\n    \"\"\"\n    self.tls_server_name = None\n    \"\"\"SSL/TLS Server Name Indication (SNI)\n       Set this to the SNI value expected by the server.\n    \"\"\"\n\n\n    self.proxy = None\n    \"\"\"Proxy URL\n    \"\"\"\n    self.proxy_headers = None\n    \"\"\"Proxy headers\n    \"\"\"\n    self.safe_chars_for_path_param = ''\n    \"\"\"Safe chars for path_param\n    \"\"\"\n    self.retries = None\n    \"\"\"Adding retries to override urllib3 default value 3\n    \"\"\"\n    # Enable client side validation\n    self.client_side_validation = True\n\n    self.socket_options = None\n    \"\"\"Options to pass down to the underlying urllib3 socket\n    \"\"\"\n\n    self.datetime_format = \"%Y-%m-%dT%H:%M:%S.%f%z\"\n    \"\"\"datetime format\n    \"\"\"\n\n    self.date_format = \"%Y-%m-%d\"\n    \"\"\"date format\n    \"\"\"\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.auth_settings","title":"<code>auth_settings()</code>","text":"<p>Gets Auth Settings dict for api client.</p> <p>Returns:</p> Type Description <p>The Auth Settings information dict.</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>def auth_settings(self):\n    \"\"\"Gets Auth Settings dict for api client.\n\n    :return: The Auth Settings information dict.\n    \"\"\"\n    auth = {}\n    return auth\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.get_api_key_with_prefix","title":"<code>get_api_key_with_prefix(identifier, alias=None)</code>","text":"<p>Gets API key (with prefix if set).</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <p>The identifier of apiKey.</p> required <code>alias</code> <p>The alternative identifier of apiKey.</p> <code>None</code> <p>Returns:</p> Type Description <p>The token for api key authentication.</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>def get_api_key_with_prefix(self, identifier, alias=None):\n    \"\"\"Gets API key (with prefix if set).\n\n    :param identifier: The identifier of apiKey.\n    :param alias: The alternative identifier of apiKey.\n    :return: The token for api key authentication.\n    \"\"\"\n    if self.refresh_api_key_hook is not None:\n        self.refresh_api_key_hook(self)\n    key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)\n    if key:\n        prefix = self.api_key_prefix.get(identifier)\n        if prefix:\n            return \"%s %s\" % (prefix, key)\n        else:\n            return key\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.get_basic_auth_token","title":"<code>get_basic_auth_token()</code>","text":"<p>Gets HTTP basic authentication header (string).</p> <p>Returns:</p> Type Description <p>The token for basic HTTP authentication.</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>def get_basic_auth_token(self):\n    \"\"\"Gets HTTP basic authentication header (string).\n\n    :return: The token for basic HTTP authentication.\n    \"\"\"\n    username = \"\"\n    if self.username is not None:\n        username = self.username\n    password = \"\"\n    if self.password is not None:\n        password = self.password\n    return urllib3.util.make_headers(\n        basic_auth=username + ':' + password\n    ).get('authorization')\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.get_default","title":"<code>get_default()</code>  <code>classmethod</code>","text":"<p>Return the default configuration.</p> <p>This method returns newly created, based on default constructor, object of Configuration class or returns a copy of default configuration.</p> <p>Returns:</p> Type Description <p>The configuration object.</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>@classmethod\ndef get_default(cls):\n    \"\"\"Return the default configuration.\n\n    This method returns newly created, based on default constructor,\n    object of Configuration class or returns a copy of default\n    configuration.\n\n    :return: The configuration object.\n    \"\"\"\n    if cls._default is None:\n        cls._default = Configuration()\n    return cls._default\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.get_default_copy","title":"<code>get_default_copy()</code>  <code>classmethod</code>","text":"<p>Deprecated. Please use <code>get_default</code> instead.</p> <p>Deprecated. Please use <code>get_default</code> instead.</p> <p>Returns:</p> Type Description <p>The configuration object.</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>@classmethod\ndef get_default_copy(cls):\n    \"\"\"Deprecated. Please use `get_default` instead.\n\n    Deprecated. Please use `get_default` instead.\n\n    :return: The configuration object.\n    \"\"\"\n    return cls.get_default()\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.get_host_from_settings","title":"<code>get_host_from_settings(index, variables=None, servers=None)</code>","text":"<p>Gets host URL based on the index and variables</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <p>array index of the host settings</p> required <code>variables</code> <p>hash of variable and the corresponding value</p> <code>None</code> <code>servers</code> <p>an array of host settings or None</p> <code>None</code> <p>Returns:</p> Type Description <p>URL based on host settings</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>def get_host_from_settings(self, index, variables=None, servers=None):\n    \"\"\"Gets host URL based on the index and variables\n    :param index: array index of the host settings\n    :param variables: hash of variable and the corresponding value\n    :param servers: an array of host settings or None\n    :return: URL based on host settings\n    \"\"\"\n    if index is None:\n        return self._base_path\n\n    variables = {} if variables is None else variables\n    servers = self.get_host_settings() if servers is None else servers\n\n    try:\n        server = servers[index]\n    except IndexError:\n        raise ValueError(\n            \"Invalid index {0} when selecting the host settings. \"\n            \"Must be less than {1}\".format(index, len(servers)))\n\n    url = server['url']\n\n    # go through variables and replace placeholders\n    for variable_name, variable in server.get('variables', {}).items():\n        used_value = variables.get(\n            variable_name, variable['default_value'])\n\n        if 'enum_values' in variable \\\n                and used_value not in variable['enum_values']:\n            raise ValueError(\n                \"The variable `{0}` in the host URL has invalid value \"\n                \"{1}. Must be {2}.\".format(\n                    variable_name, variables[variable_name],\n                    variable['enum_values']))\n\n        url = url.replace(\"{\" + variable_name + \"}\", used_value)\n\n    return url\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.get_host_settings","title":"<code>get_host_settings()</code>","text":"<p>Gets an array of host settings</p> <p>Returns:</p> Type Description <p>An array of host settings</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>def get_host_settings(self):\n    \"\"\"Gets an array of host settings\n\n    :return: An array of host settings\n    \"\"\"\n    return [\n        {\n            'url': \"\",\n            'description': \"No description provided\",\n        }\n    ]\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.set_default","title":"<code>set_default(default)</code>  <code>classmethod</code>","text":"<p>Set default instance of configuration.</p> <p>It stores default configuration, which can be returned by get_default_copy method.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <p>object of Configuration</p> required Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>@classmethod\ndef set_default(cls, default):\n    \"\"\"Set default instance of configuration.\n\n    It stores default configuration, which can be\n    returned by get_default_copy method.\n\n    :param default: object of Configuration\n    \"\"\"\n    cls._default = default\n</code></pre>"},{"location":"API_Documentation/configuration/#cheshire_cat_api.configuration.Configuration.to_debug_report","title":"<code>to_debug_report()</code>","text":"<p>Gets the essential information for debugging.</p> <p>Returns:</p> Type Description <p>The report for debugging.</p> Source code in <code>cheshire_cat_api/configuration.py</code> <pre><code>def to_debug_report(self):\n    \"\"\"Gets the essential information for debugging.\n\n    :return: The report for debugging.\n    \"\"\"\n    return \"Python SDK Debug Report:\\n\"\\\n           \"OS: {env}\\n\"\\\n           \"Python Version: {pyversion}\\n\"\\\n           \"Version of the API: 1.3.1\\n\"\\\n           \"SDK Package Version: 1.0.0\".\\\n           format(env=sys.platform, pyversion=sys.version)\n</code></pre>"},{"location":"API_Documentation/exceptions/","title":"exceptions","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiAttributeError","title":"<code>ApiAttributeError</code>","text":"<p>               Bases: <code>OpenApiException</code>, <code>AttributeError</code></p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>class ApiAttributeError(OpenApiException, AttributeError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Raised when an attribute reference or assignment fails.\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiAttributeError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiAttributeError.__init__","title":"<code>__init__(msg, path_to_item=None)</code>","text":"<p>Raised when an attribute reference or assignment fails.</p> <p>Args:     msg (str): the exception message</p> <p>Keyword Args:     path_to_item (None/list) the path to the exception in the         received_data dict</p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>def __init__(self, msg, path_to_item=None) -&gt; None:\n    \"\"\"\n    Raised when an attribute reference or assignment fails.\n\n    Args:\n        msg (str): the exception message\n\n    Keyword Args:\n        path_to_item (None/list) the path to the exception in the\n            received_data dict\n    \"\"\"\n    self.path_to_item = path_to_item\n    full_msg = msg\n    if path_to_item:\n        full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n    super(ApiAttributeError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiException","title":"<code>ApiException</code>","text":"<p>               Bases: <code>OpenApiException</code></p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>class ApiException(OpenApiException):\n\n    def __init__(self, status=None, reason=None, http_resp=None) -&gt; None:\n        if http_resp:\n            self.status = http_resp.status\n            self.reason = http_resp.reason\n            self.body = http_resp.data.decode('utf-8')\n            self.headers = http_resp.getheaders()\n        else:\n            self.status = status\n            self.reason = reason\n            self.body = None\n            self.headers = None\n\n    def __str__(self):\n        \"\"\"Custom error messages for exception\"\"\"\n        error_message = \"({0})\\n\"\\\n                        \"Reason: {1}\\n\".format(self.status, self.reason)\n        if self.headers:\n            error_message += \"HTTP response headers: {0}\\n\".format(\n                self.headers)\n\n        if self.body:\n            error_message += \"HTTP response body: {0}\\n\".format(self.body)\n\n        return error_message\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiException.__str__","title":"<code>__str__()</code>","text":"<p>Custom error messages for exception</p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>def __str__(self):\n    \"\"\"Custom error messages for exception\"\"\"\n    error_message = \"({0})\\n\"\\\n                    \"Reason: {1}\\n\".format(self.status, self.reason)\n    if self.headers:\n        error_message += \"HTTP response headers: {0}\\n\".format(\n            self.headers)\n\n    if self.body:\n        error_message += \"HTTP response body: {0}\\n\".format(self.body)\n\n    return error_message\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiKeyError","title":"<code>ApiKeyError</code>","text":"<p>               Bases: <code>OpenApiException</code>, <code>KeyError</code></p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>class ApiKeyError(OpenApiException, KeyError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (None/list) the path to the exception in the\n                received_data dict\n        \"\"\"\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiKeyError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiKeyError.__init__","title":"<code>__init__(msg, path_to_item=None)</code>","text":"<p>Args:     msg (str): the exception message</p> <p>Keyword Args:     path_to_item (None/list) the path to the exception in the         received_data dict</p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>def __init__(self, msg, path_to_item=None) -&gt; None:\n    \"\"\"\n    Args:\n        msg (str): the exception message\n\n    Keyword Args:\n        path_to_item (None/list) the path to the exception in the\n            received_data dict\n    \"\"\"\n    self.path_to_item = path_to_item\n    full_msg = msg\n    if path_to_item:\n        full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n    super(ApiKeyError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiTypeError","title":"<code>ApiTypeError</code>","text":"<p>               Bases: <code>OpenApiException</code>, <code>TypeError</code></p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>class ApiTypeError(OpenApiException, TypeError):\n    def __init__(self, msg, path_to_item=None, valid_classes=None,\n                 key_type=None) -&gt; None:\n        \"\"\" Raises an exception for TypeErrors\n\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list): a list of keys an indices to get to the\n                                 current_item\n                                 None if unset\n            valid_classes (tuple): the primitive classes that current item\n                                   should be an instance of\n                                   None if unset\n            key_type (bool): False if our value is a value in a dict\n                             True if it is a key in a dict\n                             False if our item is an item in a list\n                             None if unset\n        \"\"\"\n        self.path_to_item = path_to_item\n        self.valid_classes = valid_classes\n        self.key_type = key_type\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiTypeError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiTypeError.__init__","title":"<code>__init__(msg, path_to_item=None, valid_classes=None, key_type=None)</code>","text":"<p>Raises an exception for TypeErrors</p> <p>Args:     msg (str): the exception message</p> <p>Keyword Args:     path_to_item (list): a list of keys an indices to get to the                          current_item                          None if unset     valid_classes (tuple): the primitive classes that current item                            should be an instance of                            None if unset     key_type (bool): False if our value is a value in a dict                      True if it is a key in a dict                      False if our item is an item in a list                      None if unset</p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>def __init__(self, msg, path_to_item=None, valid_classes=None,\n             key_type=None) -&gt; None:\n    \"\"\" Raises an exception for TypeErrors\n\n    Args:\n        msg (str): the exception message\n\n    Keyword Args:\n        path_to_item (list): a list of keys an indices to get to the\n                             current_item\n                             None if unset\n        valid_classes (tuple): the primitive classes that current item\n                               should be an instance of\n                               None if unset\n        key_type (bool): False if our value is a value in a dict\n                         True if it is a key in a dict\n                         False if our item is an item in a list\n                         None if unset\n    \"\"\"\n    self.path_to_item = path_to_item\n    self.valid_classes = valid_classes\n    self.key_type = key_type\n    full_msg = msg\n    if path_to_item:\n        full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n    super(ApiTypeError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiValueError","title":"<code>ApiValueError</code>","text":"<p>               Bases: <code>OpenApiException</code>, <code>ValueError</code></p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>class ApiValueError(OpenApiException, ValueError):\n    def __init__(self, msg, path_to_item=None) -&gt; None:\n        \"\"\"\n        Args:\n            msg (str): the exception message\n\n        Keyword Args:\n            path_to_item (list) the path to the exception in the\n                received_data dict. None if unset\n        \"\"\"\n\n        self.path_to_item = path_to_item\n        full_msg = msg\n        if path_to_item:\n            full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n        super(ApiValueError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.ApiValueError.__init__","title":"<code>__init__(msg, path_to_item=None)</code>","text":"<p>Args:     msg (str): the exception message</p> <p>Keyword Args:     path_to_item (list) the path to the exception in the         received_data dict. None if unset</p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>def __init__(self, msg, path_to_item=None) -&gt; None:\n    \"\"\"\n    Args:\n        msg (str): the exception message\n\n    Keyword Args:\n        path_to_item (list) the path to the exception in the\n            received_data dict. None if unset\n    \"\"\"\n\n    self.path_to_item = path_to_item\n    full_msg = msg\n    if path_to_item:\n        full_msg = \"{0} at {1}\".format(msg, render_path(path_to_item))\n    super(ApiValueError, self).__init__(full_msg)\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.OpenApiException","title":"<code>OpenApiException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The base exception class for all OpenAPIExceptions</p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>class OpenApiException(Exception):\n    \"\"\"The base exception class for all OpenAPIExceptions\"\"\"\n</code></pre>"},{"location":"API_Documentation/exceptions/#cheshire_cat_api.exceptions.render_path","title":"<code>render_path(path_to_item)</code>","text":"<p>Returns a string representation of a path</p> Source code in <code>cheshire_cat_api/exceptions.py</code> <pre><code>def render_path(path_to_item):\n    \"\"\"Returns a string representation of a path\"\"\"\n    result = \"\"\n    for pth in path_to_item:\n        if isinstance(pth, int):\n            result += \"[{0}]\".format(pth)\n        else:\n            result += \"['{0}']\".format(pth)\n    return result\n</code></pre>"},{"location":"API_Documentation/rest/","title":"rest","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/rest/#cheshire_cat_api.rest.RESTClientObject","title":"<code>RESTClientObject</code>","text":"Source code in <code>cheshire_cat_api/rest.py</code> <pre><code>class RESTClientObject:\n\n    def __init__(self, configuration) -&gt; None:\n        # urllib3.PoolManager will pass all kw parameters to connectionpool\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501\n        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501\n        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501\n\n        # cert_reqs\n        if configuration.verify_ssl:\n            cert_reqs = ssl.CERT_REQUIRED\n        else:\n            cert_reqs = ssl.CERT_NONE\n\n        addition_pool_args = {}\n        if configuration.assert_hostname is not None:\n            addition_pool_args['assert_hostname'] = (\n                configuration.assert_hostname\n            )\n\n        if configuration.retries is not None:\n            addition_pool_args['retries'] = configuration.retries\n\n        if configuration.tls_server_name:\n            addition_pool_args['server_hostname'] = configuration.tls_server_name\n\n\n        if configuration.socket_options is not None:\n            addition_pool_args['socket_options'] = configuration.socket_options\n\n        # https pool manager\n        if configuration.proxy:\n            self.pool_manager = urllib3.ProxyManager(\n                cert_reqs=cert_reqs,\n                ca_certs=configuration.ssl_ca_cert,\n                cert_file=configuration.cert_file,\n                key_file=configuration.key_file,\n                proxy_url=configuration.proxy,\n                proxy_headers=configuration.proxy_headers,\n                **addition_pool_args\n            )\n        else:\n            self.pool_manager = urllib3.PoolManager(\n                cert_reqs=cert_reqs,\n                ca_certs=configuration.ssl_ca_cert,\n                cert_file=configuration.cert_file,\n                key_file=configuration.key_file,\n                **addition_pool_args\n            )\n\n    def request(\n        self,\n        method,\n        url,\n        headers=None,\n        body=None,\n        post_params=None,\n        _request_timeout=None\n    ):\n        \"\"\"Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        \"\"\"\n        method = method.upper()\n        assert method in [\n            'GET',\n            'HEAD',\n            'DELETE',\n            'POST',\n            'PUT',\n            'PATCH',\n            'OPTIONS'\n        ]\n\n        if post_params and body:\n            raise ApiValueError(\n                \"body parameter cannot be used with post_params parameter.\"\n            )\n\n        post_params = post_params or {}\n        headers = headers or {}\n\n        timeout = None\n        if _request_timeout:\n            if isinstance(_request_timeout, (int, float)):\n                timeout = urllib3.Timeout(total=_request_timeout)\n            elif (\n                    isinstance(_request_timeout, tuple)\n                    and len(_request_timeout) == 2\n                ):\n                timeout = urllib3.Timeout(\n                    connect=_request_timeout[0],\n                    read=_request_timeout[1]\n                )\n\n        try:\n            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:\n\n                # no content type provided or payload is json\n                content_type = headers.get('Content-Type')\n                if (\n                    not content_type\n                    or re.search('json', content_type, re.IGNORECASE)\n                ):\n                    request_body = None\n                    if body is not None:\n                        request_body = json.dumps(body)\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=request_body,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False\n                    )\n                elif content_type == 'application/x-www-form-urlencoded':\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=False,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False\n                    )\n                elif content_type == 'multipart/form-data':\n                    # must del headers['Content-Type'], or the correct\n                    # Content-Type which generated by urllib3 will be\n                    # overwritten.\n                    del headers['Content-Type']\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        fields=post_params,\n                        encode_multipart=True,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False\n                    )\n                # Pass a `string` parameter directly in the body to support\n                # other content types than Json when `body` argument is\n                # provided in serialized form\n                elif isinstance(body, str) or isinstance(body, bytes):\n                    request_body = body\n                    r = self.pool_manager.request(\n                        method,\n                        url,\n                        body=request_body,\n                        timeout=timeout,\n                        headers=headers,\n                        preload_content=False\n                    )\n                else:\n                    # Cannot generate the request from given parameters\n                    msg = \"\"\"Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.\"\"\"\n                    raise ApiException(status=0, reason=msg)\n            # For `GET`, `HEAD`\n            else:\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields={},\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False\n                )\n        except urllib3.exceptions.SSLError as e:\n            msg = \"\\n\".join([type(e).__name__, str(e)])\n            raise ApiException(status=0, reason=msg)\n\n        return RESTResponse(r)\n</code></pre>"},{"location":"API_Documentation/rest/#cheshire_cat_api.rest.RESTClientObject.request","title":"<code>request(method, url, headers=None, body=None, post_params=None, _request_timeout=None)</code>","text":"<p>Perform requests.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>http request method</p> required <code>url</code> <p>http request url</p> required <code>headers</code> <p>http request headers</p> <code>None</code> <code>body</code> <p>request json body, for <code>application/json</code></p> <code>None</code> <code>post_params</code> <p>request post parameters, <code>application/x-www-form-urlencoded</code> and <code>multipart/form-data</code></p> <code>None</code> <code>_request_timeout</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> Source code in <code>cheshire_cat_api/rest.py</code> <pre><code>def request(\n    self,\n    method,\n    url,\n    headers=None,\n    body=None,\n    post_params=None,\n    _request_timeout=None\n):\n    \"\"\"Perform requests.\n\n    :param method: http request method\n    :param url: http request url\n    :param headers: http request headers\n    :param body: request json body, for `application/json`\n    :param post_params: request post parameters,\n                        `application/x-www-form-urlencoded`\n                        and `multipart/form-data`\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    \"\"\"\n    method = method.upper()\n    assert method in [\n        'GET',\n        'HEAD',\n        'DELETE',\n        'POST',\n        'PUT',\n        'PATCH',\n        'OPTIONS'\n    ]\n\n    if post_params and body:\n        raise ApiValueError(\n            \"body parameter cannot be used with post_params parameter.\"\n        )\n\n    post_params = post_params or {}\n    headers = headers or {}\n\n    timeout = None\n    if _request_timeout:\n        if isinstance(_request_timeout, (int, float)):\n            timeout = urllib3.Timeout(total=_request_timeout)\n        elif (\n                isinstance(_request_timeout, tuple)\n                and len(_request_timeout) == 2\n            ):\n            timeout = urllib3.Timeout(\n                connect=_request_timeout[0],\n                read=_request_timeout[1]\n            )\n\n    try:\n        # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`\n        if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:\n\n            # no content type provided or payload is json\n            content_type = headers.get('Content-Type')\n            if (\n                not content_type\n                or re.search('json', content_type, re.IGNORECASE)\n            ):\n                request_body = None\n                if body is not None:\n                    request_body = json.dumps(body)\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=request_body,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False\n                )\n            elif content_type == 'application/x-www-form-urlencoded':\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields=post_params,\n                    encode_multipart=False,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False\n                )\n            elif content_type == 'multipart/form-data':\n                # must del headers['Content-Type'], or the correct\n                # Content-Type which generated by urllib3 will be\n                # overwritten.\n                del headers['Content-Type']\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    fields=post_params,\n                    encode_multipart=True,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False\n                )\n            # Pass a `string` parameter directly in the body to support\n            # other content types than Json when `body` argument is\n            # provided in serialized form\n            elif isinstance(body, str) or isinstance(body, bytes):\n                request_body = body\n                r = self.pool_manager.request(\n                    method,\n                    url,\n                    body=request_body,\n                    timeout=timeout,\n                    headers=headers,\n                    preload_content=False\n                )\n            else:\n                # Cannot generate the request from given parameters\n                msg = \"\"\"Cannot prepare a request message for provided\n                         arguments. Please check that your arguments match\n                         declared content type.\"\"\"\n                raise ApiException(status=0, reason=msg)\n        # For `GET`, `HEAD`\n        else:\n            r = self.pool_manager.request(\n                method,\n                url,\n                fields={},\n                timeout=timeout,\n                headers=headers,\n                preload_content=False\n            )\n    except urllib3.exceptions.SSLError as e:\n        msg = \"\\n\".join([type(e).__name__, str(e)])\n        raise ApiException(status=0, reason=msg)\n\n    return RESTResponse(r)\n</code></pre>"},{"location":"API_Documentation/rest/#cheshire_cat_api.rest.RESTResponse","title":"<code>RESTResponse</code>","text":"<p>               Bases: <code>IOBase</code></p> Source code in <code>cheshire_cat_api/rest.py</code> <pre><code>class RESTResponse(io.IOBase):\n\n    def __init__(self, resp) -&gt; None:\n        self.response = resp\n        self.status = resp.status\n        self.reason = resp.reason\n        self.data = None\n\n    def read(self):\n        if self.data is None:\n            self.data = self.response.data\n        return self.data\n\n    def getheaders(self):\n        \"\"\"Returns a dictionary of the response headers.\"\"\"\n        return self.response.headers\n\n    def getheader(self, name, default=None):\n        \"\"\"Returns a given response header.\"\"\"\n        return self.response.headers.get(name, default)\n</code></pre>"},{"location":"API_Documentation/rest/#cheshire_cat_api.rest.RESTResponse.getheader","title":"<code>getheader(name, default=None)</code>","text":"<p>Returns a given response header.</p> Source code in <code>cheshire_cat_api/rest.py</code> <pre><code>def getheader(self, name, default=None):\n    \"\"\"Returns a given response header.\"\"\"\n    return self.response.headers.get(name, default)\n</code></pre>"},{"location":"API_Documentation/rest/#cheshire_cat_api.rest.RESTResponse.getheaders","title":"<code>getheaders()</code>","text":"<p>Returns a dictionary of the response headers.</p> Source code in <code>cheshire_cat_api/rest.py</code> <pre><code>def getheaders(self):\n    \"\"\"Returns a dictionary of the response headers.\"\"\"\n    return self.response.headers\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/","title":"embedder_api","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi","title":"<code>EmbedderApi</code>","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>class EmbedderApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n\n    @validate_call\n    def get_embedder_settings(\n        self,\n        language_embedder_name: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Embedder Settings\n\n        Get settings and schema of the specified Embedder\n\n        :param language_embedder_name: (required)\n        :type language_embedder_name: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_embedder_settings_serialize(\n            language_embedder_name=language_embedder_name,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_embedder_settings_with_http_info(\n        self,\n        language_embedder_name: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Embedder Settings\n\n        Get settings and schema of the specified Embedder\n\n        :param language_embedder_name: (required)\n        :type language_embedder_name: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_embedder_settings_serialize(\n            language_embedder_name=language_embedder_name,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_embedder_settings_without_preload_content(\n        self,\n        language_embedder_name: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Embedder Settings\n\n        Get settings and schema of the specified Embedder\n\n        :param language_embedder_name: (required)\n        :type language_embedder_name: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_embedder_settings_serialize(\n            language_embedder_name=language_embedder_name,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_embedder_settings_serialize(\n        self,\n        language_embedder_name,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if language_embedder_name is not None:\n            _path_params['languageEmbedderName'] = language_embedder_name\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/embedder/settings/{languageEmbedderName}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_embedders_settings(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Embedders Settings\n\n        Get the list of the Embedders\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_embedders_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_embedders_settings_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Embedders Settings\n\n        Get the list of the Embedders\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_embedders_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_embedders_settings_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Embedders Settings\n\n        Get the list of the Embedders\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_embedders_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_embedders_settings_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/embedder/settings/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def upsert_embedder_setting(\n        self,\n        language_embedder_name: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Upsert Embedder Setting\n\n        Upsert the Embedder setting\n\n        :param language_embedder_name: (required)\n        :type language_embedder_name: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_embedder_setting_serialize(\n            language_embedder_name=language_embedder_name,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def upsert_embedder_setting_with_http_info(\n        self,\n        language_embedder_name: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Upsert Embedder Setting\n\n        Upsert the Embedder setting\n\n        :param language_embedder_name: (required)\n        :type language_embedder_name: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_embedder_setting_serialize(\n            language_embedder_name=language_embedder_name,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def upsert_embedder_setting_without_preload_content(\n        self,\n        language_embedder_name: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Upsert Embedder Setting\n\n        Upsert the Embedder setting\n\n        :param language_embedder_name: (required)\n        :type language_embedder_name: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_embedder_setting_serialize(\n            language_embedder_name=language_embedder_name,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _upsert_embedder_setting_serialize(\n        self,\n        language_embedder_name,\n        body,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if language_embedder_name is not None:\n            _path_params['languageEmbedderName'] = language_embedder_name\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if body is not None:\n            _body_params = body\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='PUT',\n            resource_path='/embedder/settings/{languageEmbedderName}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.get_embedder_settings","title":"<code>get_embedder_settings(language_embedder_name, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Embedder Settings</p> <p>Get settings and schema of the specified Embedder</p> <p>Parameters:</p> Name Type Description Default <code>language_embedder_name</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef get_embedder_settings(\n    self,\n    language_embedder_name: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Embedder Settings\n\n    Get settings and schema of the specified Embedder\n\n    :param language_embedder_name: (required)\n    :type language_embedder_name: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_embedder_settings_serialize(\n        language_embedder_name=language_embedder_name,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.get_embedder_settings_with_http_info","title":"<code>get_embedder_settings_with_http_info(language_embedder_name, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Embedder Settings</p> <p>Get settings and schema of the specified Embedder</p> <p>Parameters:</p> Name Type Description Default <code>language_embedder_name</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef get_embedder_settings_with_http_info(\n    self,\n    language_embedder_name: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Embedder Settings\n\n    Get settings and schema of the specified Embedder\n\n    :param language_embedder_name: (required)\n    :type language_embedder_name: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_embedder_settings_serialize(\n        language_embedder_name=language_embedder_name,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.get_embedder_settings_without_preload_content","title":"<code>get_embedder_settings_without_preload_content(language_embedder_name, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Embedder Settings</p> <p>Get settings and schema of the specified Embedder</p> <p>Parameters:</p> Name Type Description Default <code>language_embedder_name</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef get_embedder_settings_without_preload_content(\n    self,\n    language_embedder_name: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Embedder Settings\n\n    Get settings and schema of the specified Embedder\n\n    :param language_embedder_name: (required)\n    :type language_embedder_name: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_embedder_settings_serialize(\n        language_embedder_name=language_embedder_name,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.get_embedders_settings","title":"<code>get_embedders_settings(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Embedders Settings</p> <p>Get the list of the Embedders</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef get_embedders_settings(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Embedders Settings\n\n    Get the list of the Embedders\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_embedders_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.get_embedders_settings_with_http_info","title":"<code>get_embedders_settings_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Embedders Settings</p> <p>Get the list of the Embedders</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef get_embedders_settings_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Embedders Settings\n\n    Get the list of the Embedders\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_embedders_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.get_embedders_settings_without_preload_content","title":"<code>get_embedders_settings_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Embedders Settings</p> <p>Get the list of the Embedders</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef get_embedders_settings_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Embedders Settings\n\n    Get the list of the Embedders\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_embedders_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.upsert_embedder_setting","title":"<code>upsert_embedder_setting(language_embedder_name, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Embedder Setting</p> <p>Upsert the Embedder setting</p> <p>Parameters:</p> Name Type Description Default <code>language_embedder_name</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef upsert_embedder_setting(\n    self,\n    language_embedder_name: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Upsert Embedder Setting\n\n    Upsert the Embedder setting\n\n    :param language_embedder_name: (required)\n    :type language_embedder_name: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_embedder_setting_serialize(\n        language_embedder_name=language_embedder_name,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.upsert_embedder_setting_with_http_info","title":"<code>upsert_embedder_setting_with_http_info(language_embedder_name, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Embedder Setting</p> <p>Upsert the Embedder setting</p> <p>Parameters:</p> Name Type Description Default <code>language_embedder_name</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef upsert_embedder_setting_with_http_info(\n    self,\n    language_embedder_name: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Upsert Embedder Setting\n\n    Upsert the Embedder setting\n\n    :param language_embedder_name: (required)\n    :type language_embedder_name: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_embedder_setting_serialize(\n        language_embedder_name=language_embedder_name,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/embedder_api/#cheshire_cat_api.api.embedder_api.EmbedderApi.upsert_embedder_setting_without_preload_content","title":"<code>upsert_embedder_setting_without_preload_content(language_embedder_name, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Embedder Setting</p> <p>Upsert the Embedder setting</p> <p>Parameters:</p> Name Type Description Default <code>language_embedder_name</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/embedder_api.py</code> <pre><code>@validate_call\ndef upsert_embedder_setting_without_preload_content(\n    self,\n    language_embedder_name: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Upsert Embedder Setting\n\n    Upsert the Embedder setting\n\n    :param language_embedder_name: (required)\n    :type language_embedder_name: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_embedder_setting_serialize(\n        language_embedder_name=language_embedder_name,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/","title":"large_language_model_api","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi","title":"<code>LargeLanguageModelApi</code>","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>class LargeLanguageModelApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n\n    @validate_call\n    def get_llm_settings(\n        self,\n        language_model_name: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Llm Settings\n\n        Get settings and schema of the specified Large Language Model\n\n        :param language_model_name: (required)\n        :type language_model_name: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_llm_settings_serialize(\n            language_model_name=language_model_name,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_llm_settings_with_http_info(\n        self,\n        language_model_name: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Llm Settings\n\n        Get settings and schema of the specified Large Language Model\n\n        :param language_model_name: (required)\n        :type language_model_name: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_llm_settings_serialize(\n            language_model_name=language_model_name,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_llm_settings_without_preload_content(\n        self,\n        language_model_name: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Llm Settings\n\n        Get settings and schema of the specified Large Language Model\n\n        :param language_model_name: (required)\n        :type language_model_name: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_llm_settings_serialize(\n            language_model_name=language_model_name,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_llm_settings_serialize(\n        self,\n        language_model_name,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if language_model_name is not None:\n            _path_params['languageModelName'] = language_model_name\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/llm/settings/{languageModelName}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_llms_settings(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Llms Settings\n\n        Get the list of the Large Language Models\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_llms_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_llms_settings_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Llms Settings\n\n        Get the list of the Large Language Models\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_llms_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_llms_settings_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Llms Settings\n\n        Get the list of the Large Language Models\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_llms_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_llms_settings_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/llm/settings/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def upsert_llm_setting(\n        self,\n        language_model_name: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Upsert Llm Setting\n\n        Upsert the Large Language Model setting\n\n        :param language_model_name: (required)\n        :type language_model_name: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_llm_setting_serialize(\n            language_model_name=language_model_name,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def upsert_llm_setting_with_http_info(\n        self,\n        language_model_name: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Upsert Llm Setting\n\n        Upsert the Large Language Model setting\n\n        :param language_model_name: (required)\n        :type language_model_name: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_llm_setting_serialize(\n            language_model_name=language_model_name,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def upsert_llm_setting_without_preload_content(\n        self,\n        language_model_name: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Upsert Llm Setting\n\n        Upsert the Large Language Model setting\n\n        :param language_model_name: (required)\n        :type language_model_name: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_llm_setting_serialize(\n            language_model_name=language_model_name,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _upsert_llm_setting_serialize(\n        self,\n        language_model_name,\n        body,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if language_model_name is not None:\n            _path_params['languageModelName'] = language_model_name\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if body is not None:\n            _body_params = body\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='PUT',\n            resource_path='/llm/settings/{languageModelName}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.get_llm_settings","title":"<code>get_llm_settings(language_model_name, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Llm Settings</p> <p>Get settings and schema of the specified Large Language Model</p> <p>Parameters:</p> Name Type Description Default <code>language_model_name</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef get_llm_settings(\n    self,\n    language_model_name: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Llm Settings\n\n    Get settings and schema of the specified Large Language Model\n\n    :param language_model_name: (required)\n    :type language_model_name: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_llm_settings_serialize(\n        language_model_name=language_model_name,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.get_llm_settings_with_http_info","title":"<code>get_llm_settings_with_http_info(language_model_name, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Llm Settings</p> <p>Get settings and schema of the specified Large Language Model</p> <p>Parameters:</p> Name Type Description Default <code>language_model_name</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef get_llm_settings_with_http_info(\n    self,\n    language_model_name: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Llm Settings\n\n    Get settings and schema of the specified Large Language Model\n\n    :param language_model_name: (required)\n    :type language_model_name: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_llm_settings_serialize(\n        language_model_name=language_model_name,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.get_llm_settings_without_preload_content","title":"<code>get_llm_settings_without_preload_content(language_model_name, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Llm Settings</p> <p>Get settings and schema of the specified Large Language Model</p> <p>Parameters:</p> Name Type Description Default <code>language_model_name</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef get_llm_settings_without_preload_content(\n    self,\n    language_model_name: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Llm Settings\n\n    Get settings and schema of the specified Large Language Model\n\n    :param language_model_name: (required)\n    :type language_model_name: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_llm_settings_serialize(\n        language_model_name=language_model_name,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.get_llms_settings","title":"<code>get_llms_settings(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Llms Settings</p> <p>Get the list of the Large Language Models</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef get_llms_settings(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Llms Settings\n\n    Get the list of the Large Language Models\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_llms_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.get_llms_settings_with_http_info","title":"<code>get_llms_settings_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Llms Settings</p> <p>Get the list of the Large Language Models</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef get_llms_settings_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Llms Settings\n\n    Get the list of the Large Language Models\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_llms_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.get_llms_settings_without_preload_content","title":"<code>get_llms_settings_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Llms Settings</p> <p>Get the list of the Large Language Models</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef get_llms_settings_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Llms Settings\n\n    Get the list of the Large Language Models\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_llms_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.upsert_llm_setting","title":"<code>upsert_llm_setting(language_model_name, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Llm Setting</p> <p>Upsert the Large Language Model setting</p> <p>Parameters:</p> Name Type Description Default <code>language_model_name</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef upsert_llm_setting(\n    self,\n    language_model_name: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Upsert Llm Setting\n\n    Upsert the Large Language Model setting\n\n    :param language_model_name: (required)\n    :type language_model_name: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_llm_setting_serialize(\n        language_model_name=language_model_name,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.upsert_llm_setting_with_http_info","title":"<code>upsert_llm_setting_with_http_info(language_model_name, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Llm Setting</p> <p>Upsert the Large Language Model setting</p> <p>Parameters:</p> Name Type Description Default <code>language_model_name</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef upsert_llm_setting_with_http_info(\n    self,\n    language_model_name: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Upsert Llm Setting\n\n    Upsert the Large Language Model setting\n\n    :param language_model_name: (required)\n    :type language_model_name: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_llm_setting_serialize(\n        language_model_name=language_model_name,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/large_language_model_api/#cheshire_cat_api.api.large_language_model_api.LargeLanguageModelApi.upsert_llm_setting_without_preload_content","title":"<code>upsert_llm_setting_without_preload_content(language_model_name, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Llm Setting</p> <p>Upsert the Large Language Model setting</p> <p>Parameters:</p> Name Type Description Default <code>language_model_name</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/large_language_model_api.py</code> <pre><code>@validate_call\ndef upsert_llm_setting_without_preload_content(\n    self,\n    language_model_name: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Upsert Llm Setting\n\n    Upsert the Large Language Model setting\n\n    :param language_model_name: (required)\n    :type language_model_name: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_llm_setting_serialize(\n        language_model_name=language_model_name,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/","title":"memory_api","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi","title":"<code>MemoryApi</code>","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>class MemoryApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n\n    @validate_call\n    def get_collections(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Collections\n\n        Get list of available collections\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_collections_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_collections_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Collections\n\n        Get list of available collections\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_collections_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_collections_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Collections\n\n        Get list of available collections\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_collections_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_collections_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/memory/collections/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_conversation_history(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Conversation History\n\n        Get the specified user's conversation history from working memory\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_conversation_history_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_conversation_history_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Conversation History\n\n        Get the specified user's conversation history from working memory\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_conversation_history_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_conversation_history_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Conversation History\n\n        Get the specified user's conversation history from working memory\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_conversation_history_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_conversation_history_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/memory/conversation_history/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def recall_memories_from_text(\n        self,\n        text: Annotated[StrictStr, Field(description=\"Find memories similar to this text.\")],\n        k: Annotated[Optional[StrictInt], Field(description=\"How many memories to return.\")] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Recall Memories From Text\n\n        Search k memories similar to given text.\n\n        :param text: Find memories similar to this text. (required)\n        :type text: str\n        :param k: How many memories to return.\n        :type k: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._recall_memories_from_text_serialize(\n            text=text,\n            k=k,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def recall_memories_from_text_with_http_info(\n        self,\n        text: Annotated[StrictStr, Field(description=\"Find memories similar to this text.\")],\n        k: Annotated[Optional[StrictInt], Field(description=\"How many memories to return.\")] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Recall Memories From Text\n\n        Search k memories similar to given text.\n\n        :param text: Find memories similar to this text. (required)\n        :type text: str\n        :param k: How many memories to return.\n        :type k: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._recall_memories_from_text_serialize(\n            text=text,\n            k=k,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def recall_memories_from_text_without_preload_content(\n        self,\n        text: Annotated[StrictStr, Field(description=\"Find memories similar to this text.\")],\n        k: Annotated[Optional[StrictInt], Field(description=\"How many memories to return.\")] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Recall Memories From Text\n\n        Search k memories similar to given text.\n\n        :param text: Find memories similar to this text. (required)\n        :type text: str\n        :param k: How many memories to return.\n        :type k: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._recall_memories_from_text_serialize(\n            text=text,\n            k=k,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _recall_memories_from_text_serialize(\n        self,\n        text,\n        k,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        if text is not None:\n\n            _query_params.append(('text', text))\n\n        if k is not None:\n\n            _query_params.append(('k', k))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/memory/recall/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def wipe_collections(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Wipe Collections\n\n        Delete and create all collections\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_collections_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def wipe_collections_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Wipe Collections\n\n        Delete and create all collections\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_collections_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def wipe_collections_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Wipe Collections\n\n        Delete and create all collections\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_collections_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _wipe_collections_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='DELETE',\n            resource_path='/memory/collections/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def wipe_conversation_history(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Wipe Conversation History\n\n        Delete the specified user's conversation history from working memory\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_conversation_history_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def wipe_conversation_history_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Wipe Conversation History\n\n        Delete the specified user's conversation history from working memory\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_conversation_history_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def wipe_conversation_history_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Wipe Conversation History\n\n        Delete the specified user's conversation history from working memory\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_conversation_history_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _wipe_conversation_history_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='DELETE',\n            resource_path='/memory/conversation_history/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def wipe_memory_point(\n        self,\n        collection_id: StrictStr,\n        memory_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Wipe Memory Point\n\n        Delete a specific point in memory\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param memory_id: (required)\n        :type memory_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_memory_point_serialize(\n            collection_id=collection_id,\n            memory_id=memory_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def wipe_memory_point_with_http_info(\n        self,\n        collection_id: StrictStr,\n        memory_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Wipe Memory Point\n\n        Delete a specific point in memory\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param memory_id: (required)\n        :type memory_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_memory_point_serialize(\n            collection_id=collection_id,\n            memory_id=memory_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def wipe_memory_point_without_preload_content(\n        self,\n        collection_id: StrictStr,\n        memory_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Wipe Memory Point\n\n        Delete a specific point in memory\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param memory_id: (required)\n        :type memory_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_memory_point_serialize(\n            collection_id=collection_id,\n            memory_id=memory_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _wipe_memory_point_serialize(\n        self,\n        collection_id,\n        memory_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if collection_id is not None:\n            _path_params['collection_id'] = collection_id\n        if memory_id is not None:\n            _path_params['memory_id'] = memory_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='DELETE',\n            resource_path='/memory/collections/{collection_id}/points/{memory_id}/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def wipe_memory_points_by_metadata(\n        self,\n        collection_id: StrictStr,\n        body: Optional[Dict[str, Any]] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Wipe Memory Points By Metadata\n\n        Delete points in memory by filter\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param body:\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_memory_points_by_metadata_serialize(\n            collection_id=collection_id,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def wipe_memory_points_by_metadata_with_http_info(\n        self,\n        collection_id: StrictStr,\n        body: Optional[Dict[str, Any]] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Wipe Memory Points By Metadata\n\n        Delete points in memory by filter\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param body:\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_memory_points_by_metadata_serialize(\n            collection_id=collection_id,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def wipe_memory_points_by_metadata_without_preload_content(\n        self,\n        collection_id: StrictStr,\n        body: Optional[Dict[str, Any]] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Wipe Memory Points By Metadata\n\n        Delete points in memory by filter\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param body:\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_memory_points_by_metadata_serialize(\n            collection_id=collection_id,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _wipe_memory_points_by_metadata_serialize(\n        self,\n        collection_id,\n        body,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if collection_id is not None:\n            _path_params['collection_id'] = collection_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if body is not None:\n            _body_params = body\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='DELETE',\n            resource_path='/memory/collections/{collection_id}/points',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def wipe_single_collection(\n        self,\n        collection_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Wipe Single Collection\n\n        Delete and recreate a collection\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_single_collection_serialize(\n            collection_id=collection_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def wipe_single_collection_with_http_info(\n        self,\n        collection_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Wipe Single Collection\n\n        Delete and recreate a collection\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_single_collection_serialize(\n            collection_id=collection_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def wipe_single_collection_without_preload_content(\n        self,\n        collection_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Wipe Single Collection\n\n        Delete and recreate a collection\n\n        :param collection_id: (required)\n        :type collection_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._wipe_single_collection_serialize(\n            collection_id=collection_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _wipe_single_collection_serialize(\n        self,\n        collection_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if collection_id is not None:\n            _path_params['collection_id'] = collection_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='DELETE',\n            resource_path='/memory/collections/{collection_id}/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.get_collections","title":"<code>get_collections(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Collections</p> <p>Get list of available collections</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef get_collections(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Collections\n\n    Get list of available collections\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_collections_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.get_collections_with_http_info","title":"<code>get_collections_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Collections</p> <p>Get list of available collections</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef get_collections_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Collections\n\n    Get list of available collections\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_collections_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.get_collections_without_preload_content","title":"<code>get_collections_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Collections</p> <p>Get list of available collections</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef get_collections_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Collections\n\n    Get list of available collections\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_collections_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.get_conversation_history","title":"<code>get_conversation_history(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Conversation History</p> <p>Get the specified user's conversation history from working memory</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef get_conversation_history(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Conversation History\n\n    Get the specified user's conversation history from working memory\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_conversation_history_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.get_conversation_history_with_http_info","title":"<code>get_conversation_history_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Conversation History</p> <p>Get the specified user's conversation history from working memory</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef get_conversation_history_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Conversation History\n\n    Get the specified user's conversation history from working memory\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_conversation_history_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.get_conversation_history_without_preload_content","title":"<code>get_conversation_history_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Conversation History</p> <p>Get the specified user's conversation history from working memory</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef get_conversation_history_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Conversation History\n\n    Get the specified user's conversation history from working memory\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_conversation_history_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.recall_memories_from_text","title":"<code>recall_memories_from_text(text, k=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Recall Memories From Text</p> <p>Search k memories similar to given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Annotated[StrictStr, Field(description='Find memories similar to this text.')]</code> <p>Find memories similar to this text. (required)</p> required <code>k</code> <code>Annotated[Optional[StrictInt], Field(description='How many memories to return.')]</code> <p>How many memories to return.</p> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef recall_memories_from_text(\n    self,\n    text: Annotated[StrictStr, Field(description=\"Find memories similar to this text.\")],\n    k: Annotated[Optional[StrictInt], Field(description=\"How many memories to return.\")] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Recall Memories From Text\n\n    Search k memories similar to given text.\n\n    :param text: Find memories similar to this text. (required)\n    :type text: str\n    :param k: How many memories to return.\n    :type k: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._recall_memories_from_text_serialize(\n        text=text,\n        k=k,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.recall_memories_from_text_with_http_info","title":"<code>recall_memories_from_text_with_http_info(text, k=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Recall Memories From Text</p> <p>Search k memories similar to given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Annotated[StrictStr, Field(description='Find memories similar to this text.')]</code> <p>Find memories similar to this text. (required)</p> required <code>k</code> <code>Annotated[Optional[StrictInt], Field(description='How many memories to return.')]</code> <p>How many memories to return.</p> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef recall_memories_from_text_with_http_info(\n    self,\n    text: Annotated[StrictStr, Field(description=\"Find memories similar to this text.\")],\n    k: Annotated[Optional[StrictInt], Field(description=\"How many memories to return.\")] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Recall Memories From Text\n\n    Search k memories similar to given text.\n\n    :param text: Find memories similar to this text. (required)\n    :type text: str\n    :param k: How many memories to return.\n    :type k: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._recall_memories_from_text_serialize(\n        text=text,\n        k=k,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.recall_memories_from_text_without_preload_content","title":"<code>recall_memories_from_text_without_preload_content(text, k=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Recall Memories From Text</p> <p>Search k memories similar to given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>Annotated[StrictStr, Field(description='Find memories similar to this text.')]</code> <p>Find memories similar to this text. (required)</p> required <code>k</code> <code>Annotated[Optional[StrictInt], Field(description='How many memories to return.')]</code> <p>How many memories to return.</p> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef recall_memories_from_text_without_preload_content(\n    self,\n    text: Annotated[StrictStr, Field(description=\"Find memories similar to this text.\")],\n    k: Annotated[Optional[StrictInt], Field(description=\"How many memories to return.\")] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Recall Memories From Text\n\n    Search k memories similar to given text.\n\n    :param text: Find memories similar to this text. (required)\n    :type text: str\n    :param k: How many memories to return.\n    :type k: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._recall_memories_from_text_serialize(\n        text=text,\n        k=k,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_collections","title":"<code>wipe_collections(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Collections</p> <p>Delete and create all collections</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_collections(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Wipe Collections\n\n    Delete and create all collections\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_collections_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_collections_with_http_info","title":"<code>wipe_collections_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Collections</p> <p>Delete and create all collections</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_collections_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Wipe Collections\n\n    Delete and create all collections\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_collections_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_collections_without_preload_content","title":"<code>wipe_collections_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Collections</p> <p>Delete and create all collections</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_collections_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Wipe Collections\n\n    Delete and create all collections\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_collections_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_conversation_history","title":"<code>wipe_conversation_history(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Conversation History</p> <p>Delete the specified user's conversation history from working memory</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_conversation_history(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Wipe Conversation History\n\n    Delete the specified user's conversation history from working memory\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_conversation_history_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_conversation_history_with_http_info","title":"<code>wipe_conversation_history_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Conversation History</p> <p>Delete the specified user's conversation history from working memory</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_conversation_history_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Wipe Conversation History\n\n    Delete the specified user's conversation history from working memory\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_conversation_history_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_conversation_history_without_preload_content","title":"<code>wipe_conversation_history_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Conversation History</p> <p>Delete the specified user's conversation history from working memory</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_conversation_history_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Wipe Conversation History\n\n    Delete the specified user's conversation history from working memory\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_conversation_history_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_memory_point","title":"<code>wipe_memory_point(collection_id, memory_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Memory Point</p> <p>Delete a specific point in memory</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>memory_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_memory_point(\n    self,\n    collection_id: StrictStr,\n    memory_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Wipe Memory Point\n\n    Delete a specific point in memory\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param memory_id: (required)\n    :type memory_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_memory_point_serialize(\n        collection_id=collection_id,\n        memory_id=memory_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_memory_point_with_http_info","title":"<code>wipe_memory_point_with_http_info(collection_id, memory_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Memory Point</p> <p>Delete a specific point in memory</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>memory_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_memory_point_with_http_info(\n    self,\n    collection_id: StrictStr,\n    memory_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Wipe Memory Point\n\n    Delete a specific point in memory\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param memory_id: (required)\n    :type memory_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_memory_point_serialize(\n        collection_id=collection_id,\n        memory_id=memory_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_memory_point_without_preload_content","title":"<code>wipe_memory_point_without_preload_content(collection_id, memory_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Memory Point</p> <p>Delete a specific point in memory</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>memory_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_memory_point_without_preload_content(\n    self,\n    collection_id: StrictStr,\n    memory_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Wipe Memory Point\n\n    Delete a specific point in memory\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param memory_id: (required)\n    :type memory_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_memory_point_serialize(\n        collection_id=collection_id,\n        memory_id=memory_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_memory_points_by_metadata","title":"<code>wipe_memory_points_by_metadata(collection_id, body=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Memory Points By Metadata</p> <p>Delete points in memory by filter</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_memory_points_by_metadata(\n    self,\n    collection_id: StrictStr,\n    body: Optional[Dict[str, Any]] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Wipe Memory Points By Metadata\n\n    Delete points in memory by filter\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param body:\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_memory_points_by_metadata_serialize(\n        collection_id=collection_id,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_memory_points_by_metadata_with_http_info","title":"<code>wipe_memory_points_by_metadata_with_http_info(collection_id, body=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Memory Points By Metadata</p> <p>Delete points in memory by filter</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_memory_points_by_metadata_with_http_info(\n    self,\n    collection_id: StrictStr,\n    body: Optional[Dict[str, Any]] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Wipe Memory Points By Metadata\n\n    Delete points in memory by filter\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param body:\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_memory_points_by_metadata_serialize(\n        collection_id=collection_id,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_memory_points_by_metadata_without_preload_content","title":"<code>wipe_memory_points_by_metadata_without_preload_content(collection_id, body=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Memory Points By Metadata</p> <p>Delete points in memory by filter</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_memory_points_by_metadata_without_preload_content(\n    self,\n    collection_id: StrictStr,\n    body: Optional[Dict[str, Any]] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Wipe Memory Points By Metadata\n\n    Delete points in memory by filter\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param body:\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_memory_points_by_metadata_serialize(\n        collection_id=collection_id,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_single_collection","title":"<code>wipe_single_collection(collection_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Single Collection</p> <p>Delete and recreate a collection</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_single_collection(\n    self,\n    collection_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Wipe Single Collection\n\n    Delete and recreate a collection\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_single_collection_serialize(\n        collection_id=collection_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_single_collection_with_http_info","title":"<code>wipe_single_collection_with_http_info(collection_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Single Collection</p> <p>Delete and recreate a collection</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_single_collection_with_http_info(\n    self,\n    collection_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Wipe Single Collection\n\n    Delete and recreate a collection\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_single_collection_serialize(\n        collection_id=collection_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/memory_api/#cheshire_cat_api.api.memory_api.MemoryApi.wipe_single_collection_without_preload_content","title":"<code>wipe_single_collection_without_preload_content(collection_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Wipe Single Collection</p> <p>Delete and recreate a collection</p> <p>Parameters:</p> Name Type Description Default <code>collection_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/memory_api.py</code> <pre><code>@validate_call\ndef wipe_single_collection_without_preload_content(\n    self,\n    collection_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Wipe Single Collection\n\n    Delete and recreate a collection\n\n    :param collection_id: (required)\n    :type collection_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._wipe_single_collection_serialize(\n        collection_id=collection_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/","title":"plugins_api","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi","title":"<code>PluginsApi</code>","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>class PluginsApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n\n    @validate_call\n    def delete_plugin(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Delete Plugin\n\n        Physically remove plugin.\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._delete_plugin_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def delete_plugin_with_http_info(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Delete Plugin\n\n        Physically remove plugin.\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._delete_plugin_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def delete_plugin_without_preload_content(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Delete Plugin\n\n        Physically remove plugin.\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._delete_plugin_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _delete_plugin_serialize(\n        self,\n        plugin_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if plugin_id is not None:\n            _path_params['plugin_id'] = plugin_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='DELETE',\n            resource_path='/plugins/{plugin_id}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_available_plugins(\n        self,\n        query: Optional[StrictStr] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Available Plugins\n\n        List available plugins\n\n        :param query:\n        :type query: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_available_plugins_serialize(\n            query=query,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_available_plugins_with_http_info(\n        self,\n        query: Optional[StrictStr] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Available Plugins\n\n        List available plugins\n\n        :param query:\n        :type query: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_available_plugins_serialize(\n            query=query,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_available_plugins_without_preload_content(\n        self,\n        query: Optional[StrictStr] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Available Plugins\n\n        List available plugins\n\n        :param query:\n        :type query: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_available_plugins_serialize(\n            query=query,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_available_plugins_serialize(\n        self,\n        query,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        if query is not None:\n\n            _query_params.append(('query', query))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/plugins/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_plugin_details(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Plugin Details\n\n        Returns information on a single plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugin_details_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_plugin_details_with_http_info(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Plugin Details\n\n        Returns information on a single plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugin_details_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_plugin_details_without_preload_content(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Plugin Details\n\n        Returns information on a single plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugin_details_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_plugin_details_serialize(\n        self,\n        plugin_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if plugin_id is not None:\n            _path_params['plugin_id'] = plugin_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/plugins/{plugin_id}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_plugin_settings(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Plugin Settings\n\n        Returns the settings of a specific plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugin_settings_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_plugin_settings_with_http_info(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Plugin Settings\n\n        Returns the settings of a specific plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugin_settings_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_plugin_settings_without_preload_content(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Plugin Settings\n\n        Returns the settings of a specific plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugin_settings_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_plugin_settings_serialize(\n        self,\n        plugin_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if plugin_id is not None:\n            _path_params['plugin_id'] = plugin_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/plugins/settings/{plugin_id}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_plugins_settings(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Plugins Settings\n\n        Returns the settings of all the plugins\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugins_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_plugins_settings_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Plugins Settings\n\n        Returns the settings of all the plugins\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugins_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_plugins_settings_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Plugins Settings\n\n        Returns the settings of all the plugins\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_plugins_settings_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_plugins_settings_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/plugins/settings/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def install_plugin(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Install Plugin\n\n        Install a new plugin from a zip file\n\n        :param file: (required)\n        :type file: bytearray\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._install_plugin_serialize(\n            file=file,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def install_plugin_with_http_info(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Install Plugin\n\n        Install a new plugin from a zip file\n\n        :param file: (required)\n        :type file: bytearray\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._install_plugin_serialize(\n            file=file,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def install_plugin_without_preload_content(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Install Plugin\n\n        Install a new plugin from a zip file\n\n        :param file: (required)\n        :type file: bytearray\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._install_plugin_serialize(\n            file=file,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _install_plugin_serialize(\n        self,\n        file,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        if file is not None:\n            _files['file'] = file\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'multipart/form-data'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='POST',\n            resource_path='/plugins/upload/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def install_plugin_from_registry(\n        self,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Install Plugin From Registry\n\n        Install a new plugin from registry\n\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._install_plugin_from_registry_serialize(\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def install_plugin_from_registry_with_http_info(\n        self,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Install Plugin From Registry\n\n        Install a new plugin from registry\n\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._install_plugin_from_registry_serialize(\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def install_plugin_from_registry_without_preload_content(\n        self,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Install Plugin From Registry\n\n        Install a new plugin from registry\n\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._install_plugin_from_registry_serialize(\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _install_plugin_from_registry_serialize(\n        self,\n        body,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if body is not None:\n            _body_params = body\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='POST',\n            resource_path='/plugins/upload/registry',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def toggle_plugin(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Toggle Plugin\n\n        Enable or disable a single plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._toggle_plugin_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def toggle_plugin_with_http_info(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Toggle Plugin\n\n        Enable or disable a single plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._toggle_plugin_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def toggle_plugin_without_preload_content(\n        self,\n        plugin_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Toggle Plugin\n\n        Enable or disable a single plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._toggle_plugin_serialize(\n            plugin_id=plugin_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _toggle_plugin_serialize(\n        self,\n        plugin_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if plugin_id is not None:\n            _path_params['plugin_id'] = plugin_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='PUT',\n            resource_path='/plugins/toggle/{plugin_id}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def upsert_plugin_settings(\n        self,\n        plugin_id: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Upsert Plugin Settings\n\n        Updates the settings of a specific plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_plugin_settings_serialize(\n            plugin_id=plugin_id,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def upsert_plugin_settings_with_http_info(\n        self,\n        plugin_id: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Upsert Plugin Settings\n\n        Updates the settings of a specific plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_plugin_settings_serialize(\n            plugin_id=plugin_id,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def upsert_plugin_settings_without_preload_content(\n        self,\n        plugin_id: StrictStr,\n        body: Dict[str, Any],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Upsert Plugin Settings\n\n        Updates the settings of a specific plugin\n\n        :param plugin_id: (required)\n        :type plugin_id: str\n        :param body: (required)\n        :type body: object\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upsert_plugin_settings_serialize(\n            plugin_id=plugin_id,\n            body=body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _upsert_plugin_settings_serialize(\n        self,\n        plugin_id,\n        body,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if plugin_id is not None:\n            _path_params['plugin_id'] = plugin_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if body is not None:\n            _body_params = body\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='PUT',\n            resource_path='/plugins/settings/{plugin_id}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.delete_plugin","title":"<code>delete_plugin(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Delete Plugin</p> <p>Physically remove plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef delete_plugin(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Delete Plugin\n\n    Physically remove plugin.\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._delete_plugin_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.delete_plugin_with_http_info","title":"<code>delete_plugin_with_http_info(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Delete Plugin</p> <p>Physically remove plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef delete_plugin_with_http_info(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Delete Plugin\n\n    Physically remove plugin.\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._delete_plugin_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.delete_plugin_without_preload_content","title":"<code>delete_plugin_without_preload_content(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Delete Plugin</p> <p>Physically remove plugin.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef delete_plugin_without_preload_content(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Delete Plugin\n\n    Physically remove plugin.\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._delete_plugin_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_available_plugins","title":"<code>get_available_plugins(query=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Available Plugins</p> <p>List available plugins</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[StrictStr]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_available_plugins(\n    self,\n    query: Optional[StrictStr] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Available Plugins\n\n    List available plugins\n\n    :param query:\n    :type query: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_available_plugins_serialize(\n        query=query,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_available_plugins_with_http_info","title":"<code>get_available_plugins_with_http_info(query=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Available Plugins</p> <p>List available plugins</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[StrictStr]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_available_plugins_with_http_info(\n    self,\n    query: Optional[StrictStr] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Available Plugins\n\n    List available plugins\n\n    :param query:\n    :type query: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_available_plugins_serialize(\n        query=query,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_available_plugins_without_preload_content","title":"<code>get_available_plugins_without_preload_content(query=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Available Plugins</p> <p>List available plugins</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Optional[StrictStr]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_available_plugins_without_preload_content(\n    self,\n    query: Optional[StrictStr] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Available Plugins\n\n    List available plugins\n\n    :param query:\n    :type query: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_available_plugins_serialize(\n        query=query,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugin_details","title":"<code>get_plugin_details(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugin Details</p> <p>Returns information on a single plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugin_details(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Plugin Details\n\n    Returns information on a single plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugin_details_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugin_details_with_http_info","title":"<code>get_plugin_details_with_http_info(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugin Details</p> <p>Returns information on a single plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugin_details_with_http_info(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Plugin Details\n\n    Returns information on a single plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugin_details_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugin_details_without_preload_content","title":"<code>get_plugin_details_without_preload_content(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugin Details</p> <p>Returns information on a single plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugin_details_without_preload_content(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Plugin Details\n\n    Returns information on a single plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugin_details_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugin_settings","title":"<code>get_plugin_settings(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugin Settings</p> <p>Returns the settings of a specific plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugin_settings(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Plugin Settings\n\n    Returns the settings of a specific plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugin_settings_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugin_settings_with_http_info","title":"<code>get_plugin_settings_with_http_info(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugin Settings</p> <p>Returns the settings of a specific plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugin_settings_with_http_info(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Plugin Settings\n\n    Returns the settings of a specific plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugin_settings_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugin_settings_without_preload_content","title":"<code>get_plugin_settings_without_preload_content(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugin Settings</p> <p>Returns the settings of a specific plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugin_settings_without_preload_content(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Plugin Settings\n\n    Returns the settings of a specific plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugin_settings_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugins_settings","title":"<code>get_plugins_settings(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugins Settings</p> <p>Returns the settings of all the plugins</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugins_settings(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Plugins Settings\n\n    Returns the settings of all the plugins\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugins_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugins_settings_with_http_info","title":"<code>get_plugins_settings_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugins Settings</p> <p>Returns the settings of all the plugins</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugins_settings_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Plugins Settings\n\n    Returns the settings of all the plugins\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugins_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.get_plugins_settings_without_preload_content","title":"<code>get_plugins_settings_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Plugins Settings</p> <p>Returns the settings of all the plugins</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef get_plugins_settings_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Plugins Settings\n\n    Returns the settings of all the plugins\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_plugins_settings_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.install_plugin","title":"<code>install_plugin(file, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Install Plugin</p> <p>Install a new plugin from a zip file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef install_plugin(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Install Plugin\n\n    Install a new plugin from a zip file\n\n    :param file: (required)\n    :type file: bytearray\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._install_plugin_serialize(\n        file=file,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.install_plugin_from_registry","title":"<code>install_plugin_from_registry(body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Install Plugin From Registry</p> <p>Install a new plugin from registry</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef install_plugin_from_registry(\n    self,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Install Plugin From Registry\n\n    Install a new plugin from registry\n\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._install_plugin_from_registry_serialize(\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.install_plugin_from_registry_with_http_info","title":"<code>install_plugin_from_registry_with_http_info(body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Install Plugin From Registry</p> <p>Install a new plugin from registry</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef install_plugin_from_registry_with_http_info(\n    self,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Install Plugin From Registry\n\n    Install a new plugin from registry\n\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._install_plugin_from_registry_serialize(\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.install_plugin_from_registry_without_preload_content","title":"<code>install_plugin_from_registry_without_preload_content(body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Install Plugin From Registry</p> <p>Install a new plugin from registry</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef install_plugin_from_registry_without_preload_content(\n    self,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Install Plugin From Registry\n\n    Install a new plugin from registry\n\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._install_plugin_from_registry_serialize(\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.install_plugin_with_http_info","title":"<code>install_plugin_with_http_info(file, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Install Plugin</p> <p>Install a new plugin from a zip file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef install_plugin_with_http_info(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Install Plugin\n\n    Install a new plugin from a zip file\n\n    :param file: (required)\n    :type file: bytearray\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._install_plugin_serialize(\n        file=file,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.install_plugin_without_preload_content","title":"<code>install_plugin_without_preload_content(file, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Install Plugin</p> <p>Install a new plugin from a zip file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef install_plugin_without_preload_content(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Install Plugin\n\n    Install a new plugin from a zip file\n\n    :param file: (required)\n    :type file: bytearray\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._install_plugin_serialize(\n        file=file,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.toggle_plugin","title":"<code>toggle_plugin(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Toggle Plugin</p> <p>Enable or disable a single plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef toggle_plugin(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Toggle Plugin\n\n    Enable or disable a single plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._toggle_plugin_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.toggle_plugin_with_http_info","title":"<code>toggle_plugin_with_http_info(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Toggle Plugin</p> <p>Enable or disable a single plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef toggle_plugin_with_http_info(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Toggle Plugin\n\n    Enable or disable a single plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._toggle_plugin_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.toggle_plugin_without_preload_content","title":"<code>toggle_plugin_without_preload_content(plugin_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Toggle Plugin</p> <p>Enable or disable a single plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef toggle_plugin_without_preload_content(\n    self,\n    plugin_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Toggle Plugin\n\n    Enable or disable a single plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._toggle_plugin_serialize(\n        plugin_id=plugin_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.upsert_plugin_settings","title":"<code>upsert_plugin_settings(plugin_id, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Plugin Settings</p> <p>Updates the settings of a specific plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef upsert_plugin_settings(\n    self,\n    plugin_id: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Upsert Plugin Settings\n\n    Updates the settings of a specific plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_plugin_settings_serialize(\n        plugin_id=plugin_id,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.upsert_plugin_settings_with_http_info","title":"<code>upsert_plugin_settings_with_http_info(plugin_id, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Plugin Settings</p> <p>Updates the settings of a specific plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef upsert_plugin_settings_with_http_info(\n    self,\n    plugin_id: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Upsert Plugin Settings\n\n    Updates the settings of a specific plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_plugin_settings_serialize(\n        plugin_id=plugin_id,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/plugins_api/#cheshire_cat_api.api.plugins_api.PluginsApi.upsert_plugin_settings_without_preload_content","title":"<code>upsert_plugin_settings_without_preload_content(plugin_id, body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upsert Plugin Settings</p> <p>Updates the settings of a specific plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin_id</code> <code>StrictStr</code> <p>(required)</p> required <code>body</code> <code>Dict[str, Any]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/plugins_api.py</code> <pre><code>@validate_call\ndef upsert_plugin_settings_without_preload_content(\n    self,\n    plugin_id: StrictStr,\n    body: Dict[str, Any],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Upsert Plugin Settings\n\n    Updates the settings of a specific plugin\n\n    :param plugin_id: (required)\n    :type plugin_id: str\n    :param body: (required)\n    :type body: object\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upsert_plugin_settings_serialize(\n        plugin_id=plugin_id,\n        body=body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/","title":"rabbit_hole_api","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi","title":"<code>RabbitHoleApi</code>","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>class RabbitHoleApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n\n    @validate_call\n    def get_allowed_mimetypes(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Allowed Mimetypes\n\n        Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_allowed_mimetypes_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_allowed_mimetypes_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Allowed Mimetypes\n\n        Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_allowed_mimetypes_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_allowed_mimetypes_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Allowed Mimetypes\n\n        Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_allowed_mimetypes_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_allowed_mimetypes_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/rabbithole/allowed-mimetypes/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def upload_file(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        chunk_size: Annotated[Optional[StrictInt], Field(description=\"Maximum length of each chunk after the document is split (in characters)\")] = None,\n        chunk_overlap: Annotated[Optional[StrictInt], Field(description=\"Chunk overlap (in characters)\")] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Upload File\n\n        Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n        :param file: (required)\n        :type file: bytearray\n        :param chunk_size: Maximum length of each chunk after the document is split (in characters)\n        :type chunk_size: int\n        :param chunk_overlap: Chunk overlap (in characters)\n        :type chunk_overlap: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_file_serialize(\n            file=file,\n            chunk_size=chunk_size,\n            chunk_overlap=chunk_overlap,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def upload_file_with_http_info(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        chunk_size: Annotated[Optional[StrictInt], Field(description=\"Maximum length of each chunk after the document is split (in characters)\")] = None,\n        chunk_overlap: Annotated[Optional[StrictInt], Field(description=\"Chunk overlap (in characters)\")] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Upload File\n\n        Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n        :param file: (required)\n        :type file: bytearray\n        :param chunk_size: Maximum length of each chunk after the document is split (in characters)\n        :type chunk_size: int\n        :param chunk_overlap: Chunk overlap (in characters)\n        :type chunk_overlap: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_file_serialize(\n            file=file,\n            chunk_size=chunk_size,\n            chunk_overlap=chunk_overlap,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def upload_file_without_preload_content(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        chunk_size: Annotated[Optional[StrictInt], Field(description=\"Maximum length of each chunk after the document is split (in characters)\")] = None,\n        chunk_overlap: Annotated[Optional[StrictInt], Field(description=\"Chunk overlap (in characters)\")] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Upload File\n\n        Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n        :param file: (required)\n        :type file: bytearray\n        :param chunk_size: Maximum length of each chunk after the document is split (in characters)\n        :type chunk_size: int\n        :param chunk_overlap: Chunk overlap (in characters)\n        :type chunk_overlap: int\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_file_serialize(\n            file=file,\n            chunk_size=chunk_size,\n            chunk_overlap=chunk_overlap,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _upload_file_serialize(\n        self,\n        file,\n        chunk_size,\n        chunk_overlap,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        if file is not None:\n            _files['file'] = file\n        if chunk_size is not None:\n            _form_params.append(('chunk_size', chunk_size))\n        if chunk_overlap is not None:\n            _form_params.append(('chunk_overlap', chunk_overlap))\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'multipart/form-data'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='POST',\n            resource_path='/rabbithole/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def upload_memory(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Upload Memory\n\n        Upload a memory json file to the cat memory\n\n        :param file: (required)\n        :type file: bytearray\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_memory_serialize(\n            file=file,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def upload_memory_with_http_info(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Upload Memory\n\n        Upload a memory json file to the cat memory\n\n        :param file: (required)\n        :type file: bytearray\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_memory_serialize(\n            file=file,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def upload_memory_without_preload_content(\n        self,\n        file: Union[StrictBytes, StrictStr],\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Upload Memory\n\n        Upload a memory json file to the cat memory\n\n        :param file: (required)\n        :type file: bytearray\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_memory_serialize(\n            file=file,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _upload_memory_serialize(\n        self,\n        file,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        if file is not None:\n            _files['file'] = file\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'multipart/form-data'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='POST',\n            resource_path='/rabbithole/memory/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def upload_url(\n        self,\n        body_upload_url: BodyUploadUrl,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Upload Url\n\n        Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n        :param body_upload_url: (required)\n        :type body_upload_url: BodyUploadUrl\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_url_serialize(\n            body_upload_url=body_upload_url,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def upload_url_with_http_info(\n        self,\n        body_upload_url: BodyUploadUrl,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Upload Url\n\n        Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n        :param body_upload_url: (required)\n        :type body_upload_url: BodyUploadUrl\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_url_serialize(\n            body_upload_url=body_upload_url,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def upload_url_without_preload_content(\n        self,\n        body_upload_url: BodyUploadUrl,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Upload Url\n\n        Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n        :param body_upload_url: (required)\n        :type body_upload_url: BodyUploadUrl\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._upload_url_serialize(\n            body_upload_url=body_upload_url,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _upload_url_serialize(\n        self,\n        body_upload_url,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if body_upload_url is not None:\n            _body_params = body_upload_url\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='POST',\n            resource_path='/rabbithole/web/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.get_allowed_mimetypes","title":"<code>get_allowed_mimetypes(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Allowed Mimetypes</p> <p>Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef get_allowed_mimetypes(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Allowed Mimetypes\n\n    Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_allowed_mimetypes_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.get_allowed_mimetypes_with_http_info","title":"<code>get_allowed_mimetypes_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Allowed Mimetypes</p> <p>Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef get_allowed_mimetypes_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Allowed Mimetypes\n\n    Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_allowed_mimetypes_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.get_allowed_mimetypes_without_preload_content","title":"<code>get_allowed_mimetypes_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Allowed Mimetypes</p> <p>Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef get_allowed_mimetypes_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Allowed Mimetypes\n\n    Retrieve the allowed mimetypes that can be ingested by the Rabbit Hole\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_allowed_mimetypes_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_file","title":"<code>upload_file(file, chunk_size=None, chunk_overlap=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload File</p> <p>Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>chunk_size</code> <code>Annotated[Optional[StrictInt], Field(description='Maximum length of each chunk after the document is split (in characters)')]</code> <p>Maximum length of each chunk after the document is split (in characters)</p> <code>None</code> <code>chunk_overlap</code> <code>Annotated[Optional[StrictInt], Field(description='Chunk overlap (in characters)')]</code> <p>Chunk overlap (in characters)</p> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_file(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    chunk_size: Annotated[Optional[StrictInt], Field(description=\"Maximum length of each chunk after the document is split (in characters)\")] = None,\n    chunk_overlap: Annotated[Optional[StrictInt], Field(description=\"Chunk overlap (in characters)\")] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Upload File\n\n    Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n    :param file: (required)\n    :type file: bytearray\n    :param chunk_size: Maximum length of each chunk after the document is split (in characters)\n    :type chunk_size: int\n    :param chunk_overlap: Chunk overlap (in characters)\n    :type chunk_overlap: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_file_serialize(\n        file=file,\n        chunk_size=chunk_size,\n        chunk_overlap=chunk_overlap,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_file_with_http_info","title":"<code>upload_file_with_http_info(file, chunk_size=None, chunk_overlap=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload File</p> <p>Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>chunk_size</code> <code>Annotated[Optional[StrictInt], Field(description='Maximum length of each chunk after the document is split (in characters)')]</code> <p>Maximum length of each chunk after the document is split (in characters)</p> <code>None</code> <code>chunk_overlap</code> <code>Annotated[Optional[StrictInt], Field(description='Chunk overlap (in characters)')]</code> <p>Chunk overlap (in characters)</p> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_file_with_http_info(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    chunk_size: Annotated[Optional[StrictInt], Field(description=\"Maximum length of each chunk after the document is split (in characters)\")] = None,\n    chunk_overlap: Annotated[Optional[StrictInt], Field(description=\"Chunk overlap (in characters)\")] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Upload File\n\n    Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n    :param file: (required)\n    :type file: bytearray\n    :param chunk_size: Maximum length of each chunk after the document is split (in characters)\n    :type chunk_size: int\n    :param chunk_overlap: Chunk overlap (in characters)\n    :type chunk_overlap: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_file_serialize(\n        file=file,\n        chunk_size=chunk_size,\n        chunk_overlap=chunk_overlap,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_file_without_preload_content","title":"<code>upload_file_without_preload_content(file, chunk_size=None, chunk_overlap=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload File</p> <p>Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>chunk_size</code> <code>Annotated[Optional[StrictInt], Field(description='Maximum length of each chunk after the document is split (in characters)')]</code> <p>Maximum length of each chunk after the document is split (in characters)</p> <code>None</code> <code>chunk_overlap</code> <code>Annotated[Optional[StrictInt], Field(description='Chunk overlap (in characters)')]</code> <p>Chunk overlap (in characters)</p> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_file_without_preload_content(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    chunk_size: Annotated[Optional[StrictInt], Field(description=\"Maximum length of each chunk after the document is split (in characters)\")] = None,\n    chunk_overlap: Annotated[Optional[StrictInt], Field(description=\"Chunk overlap (in characters)\")] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Upload File\n\n    Upload a file containing text (.txt, .md, .pdf, etc.). File content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n    :param file: (required)\n    :type file: bytearray\n    :param chunk_size: Maximum length of each chunk after the document is split (in characters)\n    :type chunk_size: int\n    :param chunk_overlap: Chunk overlap (in characters)\n    :type chunk_overlap: int\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_file_serialize(\n        file=file,\n        chunk_size=chunk_size,\n        chunk_overlap=chunk_overlap,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_memory","title":"<code>upload_memory(file, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload Memory</p> <p>Upload a memory json file to the cat memory</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_memory(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Upload Memory\n\n    Upload a memory json file to the cat memory\n\n    :param file: (required)\n    :type file: bytearray\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_memory_serialize(\n        file=file,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_memory_with_http_info","title":"<code>upload_memory_with_http_info(file, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload Memory</p> <p>Upload a memory json file to the cat memory</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_memory_with_http_info(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Upload Memory\n\n    Upload a memory json file to the cat memory\n\n    :param file: (required)\n    :type file: bytearray\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_memory_serialize(\n        file=file,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_memory_without_preload_content","title":"<code>upload_memory_without_preload_content(file, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload Memory</p> <p>Upload a memory json file to the cat memory</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[StrictBytes, StrictStr]</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_memory_without_preload_content(\n    self,\n    file: Union[StrictBytes, StrictStr],\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Upload Memory\n\n    Upload a memory json file to the cat memory\n\n    :param file: (required)\n    :type file: bytearray\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_memory_serialize(\n        file=file,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_url","title":"<code>upload_url(body_upload_url, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload Url</p> <p>Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.</p> <p>Parameters:</p> Name Type Description Default <code>body_upload_url</code> <code>BodyUploadUrl</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_url(\n    self,\n    body_upload_url: BodyUploadUrl,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Upload Url\n\n    Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n    :param body_upload_url: (required)\n    :type body_upload_url: BodyUploadUrl\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_url_serialize(\n        body_upload_url=body_upload_url,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_url_with_http_info","title":"<code>upload_url_with_http_info(body_upload_url, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload Url</p> <p>Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.</p> <p>Parameters:</p> Name Type Description Default <code>body_upload_url</code> <code>BodyUploadUrl</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_url_with_http_info(\n    self,\n    body_upload_url: BodyUploadUrl,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Upload Url\n\n    Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n    :param body_upload_url: (required)\n    :type body_upload_url: BodyUploadUrl\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_url_serialize(\n        body_upload_url=body_upload_url,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/rabbit_hole_api/#cheshire_cat_api.api.rabbit_hole_api.RabbitHoleApi.upload_url_without_preload_content","title":"<code>upload_url_without_preload_content(body_upload_url, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Upload Url</p> <p>Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.</p> <p>Parameters:</p> Name Type Description Default <code>body_upload_url</code> <code>BodyUploadUrl</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/rabbit_hole_api.py</code> <pre><code>@validate_call\ndef upload_url_without_preload_content(\n    self,\n    body_upload_url: BodyUploadUrl,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Upload Url\n\n    Upload a url. Website content will be extracted and segmented into chunks. Chunks will be then vectorized and stored into documents memory.\n\n    :param body_upload_url: (required)\n    :type body_upload_url: BodyUploadUrl\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._upload_url_serialize(\n        body_upload_url=body_upload_url,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/settings_api/","title":"settings_api","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi","title":"<code>SettingsApi</code>","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>class SettingsApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n\n    @validate_call\n    def create_setting(\n        self,\n        setting_body: SettingBody,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Create Setting\n\n        Create a new setting in the database\n\n        :param setting_body: (required)\n        :type setting_body: SettingBody\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._create_setting_serialize(\n            setting_body=setting_body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def create_setting_with_http_info(\n        self,\n        setting_body: SettingBody,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Create Setting\n\n        Create a new setting in the database\n\n        :param setting_body: (required)\n        :type setting_body: SettingBody\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._create_setting_serialize(\n            setting_body=setting_body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def create_setting_without_preload_content(\n        self,\n        setting_body: SettingBody,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Create Setting\n\n        Create a new setting in the database\n\n        :param setting_body: (required)\n        :type setting_body: SettingBody\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._create_setting_serialize(\n            setting_body=setting_body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _create_setting_serialize(\n        self,\n        setting_body,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if setting_body is not None:\n            _body_params = setting_body\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='POST',\n            resource_path='/settings/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def delete_setting(\n        self,\n        setting_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Delete Setting\n\n        Delete a specific setting in the database\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._delete_setting_serialize(\n            setting_id=setting_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def delete_setting_with_http_info(\n        self,\n        setting_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Delete Setting\n\n        Delete a specific setting in the database\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._delete_setting_serialize(\n            setting_id=setting_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def delete_setting_without_preload_content(\n        self,\n        setting_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Delete Setting\n\n        Delete a specific setting in the database\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._delete_setting_serialize(\n            setting_id=setting_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _delete_setting_serialize(\n        self,\n        setting_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if setting_id is not None:\n            _path_params['settingId'] = setting_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='DELETE',\n            resource_path='/settings/{settingId}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_setting(\n        self,\n        setting_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Setting\n\n        Get the a specific setting from the database\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_setting_serialize(\n            setting_id=setting_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_setting_with_http_info(\n        self,\n        setting_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Setting\n\n        Get the a specific setting from the database\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_setting_serialize(\n            setting_id=setting_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_setting_without_preload_content(\n        self,\n        setting_id: StrictStr,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Setting\n\n        Get the a specific setting from the database\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_setting_serialize(\n            setting_id=setting_id,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_setting_serialize(\n        self,\n        setting_id,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if setting_id is not None:\n            _path_params['settingId'] = setting_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/settings/{settingId}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def get_settings(\n        self,\n        search: Optional[StrictStr] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Get Settings\n\n        Get the entire list of settings available in the database\n\n        :param search:\n        :type search: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_settings_serialize(\n            search=search,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def get_settings_with_http_info(\n        self,\n        search: Optional[StrictStr] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Get Settings\n\n        Get the entire list of settings available in the database\n\n        :param search:\n        :type search: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_settings_serialize(\n            search=search,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def get_settings_without_preload_content(\n        self,\n        search: Optional[StrictStr] = None,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Get Settings\n\n        Get the entire list of settings available in the database\n\n        :param search:\n        :type search: str\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._get_settings_serialize(\n            search=search,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _get_settings_serialize(\n        self,\n        search,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        if search is not None:\n\n            _query_params.append(('search', search))\n\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/settings/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n\n\n\n\n    @validate_call\n    def update_setting(\n        self,\n        setting_id: StrictStr,\n        setting_body: SettingBody,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Update Setting\n\n        Update a specific setting in the database if it exists\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param setting_body: (required)\n        :type setting_body: SettingBody\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._update_setting_serialize(\n            setting_id=setting_id,\n            setting_body=setting_body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def update_setting_with_http_info(\n        self,\n        setting_id: StrictStr,\n        setting_body: SettingBody,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Update Setting\n\n        Update a specific setting in the database if it exists\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param setting_body: (required)\n        :type setting_body: SettingBody\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._update_setting_serialize(\n            setting_id=setting_id,\n            setting_body=setting_body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def update_setting_without_preload_content(\n        self,\n        setting_id: StrictStr,\n        setting_body: SettingBody,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Update Setting\n\n        Update a specific setting in the database if it exists\n\n        :param setting_id: (required)\n        :type setting_id: str\n        :param setting_body: (required)\n        :type setting_body: SettingBody\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._update_setting_serialize(\n            setting_id=setting_id,\n            setting_body=setting_body,\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\",\n            '422': \"HTTPValidationError\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _update_setting_serialize(\n        self,\n        setting_id,\n        setting_body,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        if setting_id is not None:\n            _path_params['settingId'] = setting_id\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n        if setting_body is not None:\n            _body_params = setting_body\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n        # set the HTTP header `Content-Type`\n        if _content_type:\n            _header_params['Content-Type'] = _content_type\n        else:\n            _default_content_type = (\n                self.api_client.select_header_content_type(\n                    [\n                        'application/json'\n                    ]\n                )\n            )\n            if _default_content_type is not None:\n                _header_params['Content-Type'] = _default_content_type\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='PUT',\n            resource_path='/settings/{settingId}',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.create_setting","title":"<code>create_setting(setting_body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Create Setting</p> <p>Create a new setting in the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_body</code> <code>SettingBody</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef create_setting(\n    self,\n    setting_body: SettingBody,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Create Setting\n\n    Create a new setting in the database\n\n    :param setting_body: (required)\n    :type setting_body: SettingBody\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._create_setting_serialize(\n        setting_body=setting_body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.create_setting_with_http_info","title":"<code>create_setting_with_http_info(setting_body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Create Setting</p> <p>Create a new setting in the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_body</code> <code>SettingBody</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef create_setting_with_http_info(\n    self,\n    setting_body: SettingBody,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Create Setting\n\n    Create a new setting in the database\n\n    :param setting_body: (required)\n    :type setting_body: SettingBody\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._create_setting_serialize(\n        setting_body=setting_body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.create_setting_without_preload_content","title":"<code>create_setting_without_preload_content(setting_body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Create Setting</p> <p>Create a new setting in the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_body</code> <code>SettingBody</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef create_setting_without_preload_content(\n    self,\n    setting_body: SettingBody,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Create Setting\n\n    Create a new setting in the database\n\n    :param setting_body: (required)\n    :type setting_body: SettingBody\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._create_setting_serialize(\n        setting_body=setting_body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.delete_setting","title":"<code>delete_setting(setting_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Delete Setting</p> <p>Delete a specific setting in the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef delete_setting(\n    self,\n    setting_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Delete Setting\n\n    Delete a specific setting in the database\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._delete_setting_serialize(\n        setting_id=setting_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.delete_setting_with_http_info","title":"<code>delete_setting_with_http_info(setting_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Delete Setting</p> <p>Delete a specific setting in the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef delete_setting_with_http_info(\n    self,\n    setting_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Delete Setting\n\n    Delete a specific setting in the database\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._delete_setting_serialize(\n        setting_id=setting_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.delete_setting_without_preload_content","title":"<code>delete_setting_without_preload_content(setting_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Delete Setting</p> <p>Delete a specific setting in the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef delete_setting_without_preload_content(\n    self,\n    setting_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Delete Setting\n\n    Delete a specific setting in the database\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._delete_setting_serialize(\n        setting_id=setting_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.get_setting","title":"<code>get_setting(setting_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Setting</p> <p>Get the a specific setting from the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef get_setting(\n    self,\n    setting_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Setting\n\n    Get the a specific setting from the database\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_setting_serialize(\n        setting_id=setting_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.get_setting_with_http_info","title":"<code>get_setting_with_http_info(setting_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Setting</p> <p>Get the a specific setting from the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef get_setting_with_http_info(\n    self,\n    setting_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Setting\n\n    Get the a specific setting from the database\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_setting_serialize(\n        setting_id=setting_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.get_setting_without_preload_content","title":"<code>get_setting_without_preload_content(setting_id, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Setting</p> <p>Get the a specific setting from the database</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef get_setting_without_preload_content(\n    self,\n    setting_id: StrictStr,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Setting\n\n    Get the a specific setting from the database\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_setting_serialize(\n        setting_id=setting_id,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.get_settings","title":"<code>get_settings(search=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Settings</p> <p>Get the entire list of settings available in the database</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>Optional[StrictStr]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef get_settings(\n    self,\n    search: Optional[StrictStr] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Get Settings\n\n    Get the entire list of settings available in the database\n\n    :param search:\n    :type search: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_settings_serialize(\n        search=search,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.get_settings_with_http_info","title":"<code>get_settings_with_http_info(search=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Settings</p> <p>Get the entire list of settings available in the database</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>Optional[StrictStr]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef get_settings_with_http_info(\n    self,\n    search: Optional[StrictStr] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Get Settings\n\n    Get the entire list of settings available in the database\n\n    :param search:\n    :type search: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_settings_serialize(\n        search=search,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.get_settings_without_preload_content","title":"<code>get_settings_without_preload_content(search=None, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Get Settings</p> <p>Get the entire list of settings available in the database</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>Optional[StrictStr]</code> <code>None</code> <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef get_settings_without_preload_content(\n    self,\n    search: Optional[StrictStr] = None,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Get Settings\n\n    Get the entire list of settings available in the database\n\n    :param search:\n    :type search: str\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._get_settings_serialize(\n        search=search,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.update_setting","title":"<code>update_setting(setting_id, setting_body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Update Setting</p> <p>Update a specific setting in the database if it exists</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>setting_body</code> <code>SettingBody</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef update_setting(\n    self,\n    setting_id: StrictStr,\n    setting_body: SettingBody,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Update Setting\n\n    Update a specific setting in the database if it exists\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param setting_body: (required)\n    :type setting_body: SettingBody\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._update_setting_serialize(\n        setting_id=setting_id,\n        setting_body=setting_body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.update_setting_with_http_info","title":"<code>update_setting_with_http_info(setting_id, setting_body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Update Setting</p> <p>Update a specific setting in the database if it exists</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>setting_body</code> <code>SettingBody</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef update_setting_with_http_info(\n    self,\n    setting_id: StrictStr,\n    setting_body: SettingBody,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Update Setting\n\n    Update a specific setting in the database if it exists\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param setting_body: (required)\n    :type setting_body: SettingBody\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._update_setting_serialize(\n        setting_id=setting_id,\n        setting_body=setting_body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/settings_api/#cheshire_cat_api.api.settings_api.SettingsApi.update_setting_without_preload_content","title":"<code>update_setting_without_preload_content(setting_id, setting_body, _request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Update Setting</p> <p>Update a specific setting in the database if it exists</p> <p>Parameters:</p> Name Type Description Default <code>setting_id</code> <code>StrictStr</code> <p>(required)</p> required <code>setting_body</code> <code>SettingBody</code> <p>(required)</p> required <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/settings_api.py</code> <pre><code>@validate_call\ndef update_setting_without_preload_content(\n    self,\n    setting_id: StrictStr,\n    setting_body: SettingBody,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Update Setting\n\n    Update a specific setting in the database if it exists\n\n    :param setting_id: (required)\n    :type setting_id: str\n    :param setting_body: (required)\n    :type setting_body: SettingBody\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._update_setting_serialize(\n        setting_id=setting_id,\n        setting_body=setting_body,\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\",\n        '422': \"HTTPValidationError\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/api/status_api/","title":"status_api","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/api/status_api/#cheshire_cat_api.api.status_api.StatusApi","title":"<code>StatusApi</code>","text":"<p>NOTE: This class is auto generated by OpenAPI Generator Ref: https://openapi-generator.tech</p> <p>Do not edit the class manually.</p> Source code in <code>cheshire_cat_api/api/status_api.py</code> <pre><code>class StatusApi:\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator\n    Ref: https://openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    def __init__(self, api_client=None) -&gt; None:\n        if api_client is None:\n            api_client = ApiClient.get_default()\n        self.api_client = api_client\n\n\n    @validate_call\n    def home(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; object:\n        \"\"\"Home\n\n        Server status\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._home_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        ).data\n\n\n    @validate_call\n    def home_with_http_info(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; ApiResponse[object]:\n        \"\"\"Home\n\n        Server status\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._home_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        response_data.read()\n        return self.api_client.response_deserialize(\n            response_data=response_data,\n            response_types_map=_response_types_map,\n        )\n\n\n    @validate_call\n    def home_without_preload_content(\n        self,\n        _request_timeout: Union[\n            None,\n            Annotated[StrictFloat, Field(gt=0)],\n            Tuple[\n                Annotated[StrictFloat, Field(gt=0)],\n                Annotated[StrictFloat, Field(gt=0)]\n            ]\n        ] = None,\n        _request_auth: Optional[Dict[StrictStr, Any]] = None,\n        _content_type: Optional[StrictStr] = None,\n        _headers: Optional[Dict[StrictStr, Any]] = None,\n        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n    ) -&gt; RESTResponseType:\n        \"\"\"Home\n\n        Server status\n\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        :type _request_timeout: int, tuple(int, int), optional\n        :param _request_auth: set to override the auth_settings for an a single\n                              request; this effectively ignores the\n                              authentication in the spec for a single request.\n        :type _request_auth: dict, optional\n        :param _content_type: force content-type for the request.\n        :type _content_type: str, Optional\n        :param _headers: set to override the headers for a single\n                         request; this effectively ignores the headers\n                         in the spec for a single request.\n        :type _headers: dict, optional\n        :param _host_index: set to override the host_index for a single\n                            request; this effectively ignores the host_index\n                            in the spec for a single request.\n        :type _host_index: int, optional\n        :return: Returns the result object.\n        \"\"\" # noqa: E501\n\n        _param = self._home_serialize(\n            _request_auth=_request_auth,\n            _content_type=_content_type,\n            _headers=_headers,\n            _host_index=_host_index\n        )\n\n        _response_types_map: Dict[str, Optional[str]] = {\n            '200': \"object\"\n\n        }\n        response_data = self.api_client.call_api(\n            *_param,\n            _request_timeout=_request_timeout\n        )\n        return response_data.response\n\n\n    def _home_serialize(\n        self,\n        _request_auth,\n        _content_type,\n        _headers,\n        _host_index,\n    ) -&gt; Tuple:\n\n        _host = None\n\n        _collection_formats: Dict[str, str] = {\n\n        }\n\n        _path_params: Dict[str, str] = {}\n        _query_params: List[Tuple[str, str]] = []\n        _header_params: Dict[str, Optional[str]] = _headers or {}\n        _form_params: List[Tuple[str, str]] = []\n        _files: Dict[str, str] = {}\n        _body_params: Optional[bytes] = None\n\n        # process the path parameters\n        # process the query parameters\n        # process the header parameters\n        # process the form parameters\n        # process the body parameter\n\n\n        # set the HTTP header `Accept`\n        _header_params['Accept'] = self.api_client.select_header_accept(\n            [\n                'application/json'\n            ]\n        )\n\n\n        # authentication setting\n        _auth_settings: List[str] = [\n        ]\n\n        return self.api_client.param_serialize(\n            method='GET',\n            resource_path='/',\n            path_params=_path_params,\n            query_params=_query_params,\n            header_params=_header_params,\n            body=_body_params,\n            post_params=_form_params,\n            files=_files,\n            auth_settings=_auth_settings,\n            collection_formats=_collection_formats,\n            _host=_host,\n            _request_auth=_request_auth\n        )\n</code></pre>"},{"location":"API_Documentation/api/status_api/#cheshire_cat_api.api.status_api.StatusApi.home","title":"<code>home(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Home</p> <p>Server status</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>object</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/status_api.py</code> <pre><code>@validate_call\ndef home(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; object:\n    \"\"\"Home\n\n    Server status\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._home_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    ).data\n</code></pre>"},{"location":"API_Documentation/api/status_api/#cheshire_cat_api.api.status_api.StatusApi.home_with_http_info","title":"<code>home_with_http_info(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Home</p> <p>Server status</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>ApiResponse[object]</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/status_api.py</code> <pre><code>@validate_call\ndef home_with_http_info(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; ApiResponse[object]:\n    \"\"\"Home\n\n    Server status\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._home_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    response_data.read()\n    return self.api_client.response_deserialize(\n        response_data=response_data,\n        response_types_map=_response_types_map,\n    )\n</code></pre>"},{"location":"API_Documentation/api/status_api/#cheshire_cat_api.api.status_api.StatusApi.home_without_preload_content","title":"<code>home_without_preload_content(_request_timeout=None, _request_auth=None, _content_type=None, _headers=None, _host_index=0)</code>","text":"<p>Home</p> <p>Server status</p> <p>Parameters:</p> Name Type Description Default <code>_request_timeout</code> <code>Union[None, Annotated[StrictFloat, Field(gt=0)], Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]]]</code> <p>timeout setting for this request. If one number provided, it will be total request timeout. It can also be a pair (tuple) of (connection, read) timeouts.</p> <code>None</code> <code>_request_auth</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the auth_settings for an a single request; this effectively ignores the authentication in the spec for a single request.</p> <code>None</code> <code>_content_type</code> <code>Optional[StrictStr]</code> <p>force content-type for the request.</p> <code>None</code> <code>_headers</code> <code>Optional[Dict[StrictStr, Any]]</code> <p>set to override the headers for a single request; this effectively ignores the headers in the spec for a single request.</p> <code>None</code> <code>_host_index</code> <code>Annotated[StrictInt, Field(ge=0, le=0)]</code> <p>set to override the host_index for a single request; this effectively ignores the host_index in the spec for a single request.</p> <code>0</code> <p>Returns:</p> Type Description <code>RESTResponseType</code> <p>Returns the result object.</p> Source code in <code>cheshire_cat_api/api/status_api.py</code> <pre><code>@validate_call\ndef home_without_preload_content(\n    self,\n    _request_timeout: Union[\n        None,\n        Annotated[StrictFloat, Field(gt=0)],\n        Tuple[\n            Annotated[StrictFloat, Field(gt=0)],\n            Annotated[StrictFloat, Field(gt=0)]\n        ]\n    ] = None,\n    _request_auth: Optional[Dict[StrictStr, Any]] = None,\n    _content_type: Optional[StrictStr] = None,\n    _headers: Optional[Dict[StrictStr, Any]] = None,\n    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,\n) -&gt; RESTResponseType:\n    \"\"\"Home\n\n    Server status\n\n    :param _request_timeout: timeout setting for this request. If one\n                             number provided, it will be total request\n                             timeout. It can also be a pair (tuple) of\n                             (connection, read) timeouts.\n    :type _request_timeout: int, tuple(int, int), optional\n    :param _request_auth: set to override the auth_settings for an a single\n                          request; this effectively ignores the\n                          authentication in the spec for a single request.\n    :type _request_auth: dict, optional\n    :param _content_type: force content-type for the request.\n    :type _content_type: str, Optional\n    :param _headers: set to override the headers for a single\n                     request; this effectively ignores the headers\n                     in the spec for a single request.\n    :type _headers: dict, optional\n    :param _host_index: set to override the host_index for a single\n                        request; this effectively ignores the host_index\n                        in the spec for a single request.\n    :type _host_index: int, optional\n    :return: Returns the result object.\n    \"\"\" # noqa: E501\n\n    _param = self._home_serialize(\n        _request_auth=_request_auth,\n        _content_type=_content_type,\n        _headers=_headers,\n        _host_index=_host_index\n    )\n\n    _response_types_map: Dict[str, Optional[str]] = {\n        '200': \"object\"\n\n    }\n    response_data = self.api_client.call_api(\n        *_param,\n        _request_timeout=_request_timeout\n    )\n    return response_data.response\n</code></pre>"},{"location":"API_Documentation/models/body_upload_url/","title":"body_upload_url","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/models/body_upload_url/#cheshire_cat_api.models.body_upload_url.BodyUploadUrl","title":"<code>BodyUploadUrl</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>BodyUploadUrl</p> Source code in <code>cheshire_cat_api/models/body_upload_url.py</code> <pre><code>class BodyUploadUrl(BaseModel):\n    \"\"\"\n    BodyUploadUrl\n    \"\"\" # noqa: E501\n    url: StrictStr = Field(description=\"URL of the website to which you want to save the content\")\n    chunk_size: Optional[StrictInt] = Field(default=400, description=\"Maximum length of each chunk after the document is split (in characters)\")\n    chunk_overlap: Optional[StrictInt] = Field(default=100, description=\"Chunk overlap (in characters)\")\n    __properties: ClassVar[List[str]] = [\"url\", \"chunk_size\", \"chunk_overlap\"]\n\n    model_config = {\n        \"populate_by_name\": True,\n        \"validate_assignment\": True\n    }\n\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Create an instance of BodyUploadUrl from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude={\n            },\n            exclude_none=True,\n        )\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: Dict) -&gt; Self:\n        \"\"\"Create an instance of BodyUploadUrl from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"url\": obj.get(\"url\"),\n            \"chunk_size\": obj.get(\"chunk_size\") if obj.get(\"chunk_size\") is not None else 400,\n            \"chunk_overlap\": obj.get(\"chunk_overlap\") if obj.get(\"chunk_overlap\") is not None else 100\n        })\n        return _obj\n</code></pre>"},{"location":"API_Documentation/models/body_upload_url/#cheshire_cat_api.models.body_upload_url.BodyUploadUrl.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Create an instance of BodyUploadUrl from a dict</p> Source code in <code>cheshire_cat_api/models/body_upload_url.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: Dict) -&gt; Self:\n    \"\"\"Create an instance of BodyUploadUrl from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"url\": obj.get(\"url\"),\n        \"chunk_size\": obj.get(\"chunk_size\") if obj.get(\"chunk_size\") is not None else 400,\n        \"chunk_overlap\": obj.get(\"chunk_overlap\") if obj.get(\"chunk_overlap\") is not None else 100\n    })\n    return _obj\n</code></pre>"},{"location":"API_Documentation/models/body_upload_url/#cheshire_cat_api.models.body_upload_url.BodyUploadUrl.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Create an instance of BodyUploadUrl from a JSON string</p> Source code in <code>cheshire_cat_api/models/body_upload_url.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Create an instance of BodyUploadUrl from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"API_Documentation/models/body_upload_url/#cheshire_cat_api.models.body_upload_url.BodyUploadUrl.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>cheshire_cat_api/models/body_upload_url.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude={\n        },\n        exclude_none=True,\n    )\n    return _dict\n</code></pre>"},{"location":"API_Documentation/models/body_upload_url/#cheshire_cat_api.models.body_upload_url.BodyUploadUrl.to_json","title":"<code>to_json()</code>","text":"<p>Returns the JSON representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/body_upload_url.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"API_Documentation/models/body_upload_url/#cheshire_cat_api.models.body_upload_url.BodyUploadUrl.to_str","title":"<code>to_str()</code>","text":"<p>Returns the string representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/body_upload_url.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"API_Documentation/models/http_validation_error/","title":"http_validation_error","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/models/http_validation_error/#cheshire_cat_api.models.http_validation_error.HTTPValidationError","title":"<code>HTTPValidationError</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>HTTPValidationError</p> Source code in <code>cheshire_cat_api/models/http_validation_error.py</code> <pre><code>class HTTPValidationError(BaseModel):\n    \"\"\"\n    HTTPValidationError\n    \"\"\" # noqa: E501\n    detail: Optional[List[ValidationError]] = None\n    __properties: ClassVar[List[str]] = [\"detail\"]\n\n    model_config = {\n        \"populate_by_name\": True,\n        \"validate_assignment\": True\n    }\n\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Create an instance of HTTPValidationError from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude={\n            },\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of each item in detail (list)\n        _items = []\n        if self.detail:\n            for _item in self.detail:\n                if _item:\n                    _items.append(_item.to_dict())\n            _dict['detail'] = _items\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: Dict) -&gt; Self:\n        \"\"\"Create an instance of HTTPValidationError from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"detail\": [ValidationError.from_dict(_item) for _item in obj.get(\"detail\")] if obj.get(\"detail\") is not None else None\n        })\n        return _obj\n</code></pre>"},{"location":"API_Documentation/models/http_validation_error/#cheshire_cat_api.models.http_validation_error.HTTPValidationError.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Create an instance of HTTPValidationError from a dict</p> Source code in <code>cheshire_cat_api/models/http_validation_error.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: Dict) -&gt; Self:\n    \"\"\"Create an instance of HTTPValidationError from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"detail\": [ValidationError.from_dict(_item) for _item in obj.get(\"detail\")] if obj.get(\"detail\") is not None else None\n    })\n    return _obj\n</code></pre>"},{"location":"API_Documentation/models/http_validation_error/#cheshire_cat_api.models.http_validation_error.HTTPValidationError.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Create an instance of HTTPValidationError from a JSON string</p> Source code in <code>cheshire_cat_api/models/http_validation_error.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Create an instance of HTTPValidationError from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"API_Documentation/models/http_validation_error/#cheshire_cat_api.models.http_validation_error.HTTPValidationError.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>cheshire_cat_api/models/http_validation_error.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude={\n        },\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of each item in detail (list)\n    _items = []\n    if self.detail:\n        for _item in self.detail:\n            if _item:\n                _items.append(_item.to_dict())\n        _dict['detail'] = _items\n    return _dict\n</code></pre>"},{"location":"API_Documentation/models/http_validation_error/#cheshire_cat_api.models.http_validation_error.HTTPValidationError.to_json","title":"<code>to_json()</code>","text":"<p>Returns the JSON representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/http_validation_error.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"API_Documentation/models/http_validation_error/#cheshire_cat_api.models.http_validation_error.HTTPValidationError.to_str","title":"<code>to_str()</code>","text":"<p>Returns the string representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/http_validation_error.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"API_Documentation/models/location_inner/","title":"location_inner","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/models/location_inner/#cheshire_cat_api.models.location_inner.LocationInner","title":"<code>LocationInner</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>LocationInner</p> Source code in <code>cheshire_cat_api/models/location_inner.py</code> <pre><code>class LocationInner(BaseModel):\n    \"\"\"\n    LocationInner\n    \"\"\"\n\n    # data type: str\n    anyof_schema_1_validator: Optional[StrictStr] = None\n    # data type: int\n    anyof_schema_2_validator: Optional[StrictInt] = None\n    if TYPE_CHECKING:\n        actual_instance: Optional[Union[int, str]] = None\n    else:\n        actual_instance: Any = None\n    any_of_schemas: List[str] = Literal[LOCATIONINNER_ANY_OF_SCHEMAS]\n\n    model_config = {\n        \"validate_assignment\": True\n    }\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        if args:\n            if len(args) &gt; 1:\n                raise ValueError(\"If a position argument is used, only 1 is allowed to set `actual_instance`\")\n            if kwargs:\n                raise ValueError(\"If a position argument is used, keyword arguments cannot be used.\")\n            super().__init__(actual_instance=args[0])\n        else:\n            super().__init__(**kwargs)\n\n    @field_validator('actual_instance')\n    def actual_instance_must_validate_anyof(cls, v):\n        instance = LocationInner.model_construct()\n        error_messages = []\n        # validate data type: str\n        try:\n            instance.anyof_schema_1_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # validate data type: int\n        try:\n            instance.anyof_schema_2_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        if error_messages:\n            # no match\n            raise ValueError(\"No match found when setting the actual_instance in LocationInner with anyOf schemas: int, str. Details: \" + \", \".join(error_messages))\n        else:\n            return v\n\n    @classmethod\n    def from_dict(cls, obj: dict) -&gt; Self:\n        return cls.from_json(json.dumps(obj))\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Returns the object represented by the json string\"\"\"\n        instance = cls.model_construct()\n        error_messages = []\n        # deserialize data into str\n        try:\n            # validation\n            instance.anyof_schema_1_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_1_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # deserialize data into int\n        try:\n            # validation\n            instance.anyof_schema_2_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_2_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n\n        if error_messages:\n            # no match\n            raise ValueError(\"No match found when deserializing the JSON string into LocationInner with anyOf schemas: int, str. Details: \" + \", \".join(error_messages))\n        else:\n            return instance\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return \"null\"\n\n        to_json = getattr(self.actual_instance, \"to_json\", None)\n        if callable(to_json):\n            return self.actual_instance.to_json()\n        else:\n            return json.dumps(self.actual_instance)\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"Returns the dict representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return \"null\"\n\n        to_json = getattr(self.actual_instance, \"to_json\", None)\n        if callable(to_json):\n            return self.actual_instance.to_dict()\n        else:\n            return json.dumps(self.actual_instance)\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the actual instance\"\"\"\n        return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"API_Documentation/models/location_inner/#cheshire_cat_api.models.location_inner.LocationInner.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Returns the object represented by the json string</p> Source code in <code>cheshire_cat_api/models/location_inner.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Returns the object represented by the json string\"\"\"\n    instance = cls.model_construct()\n    error_messages = []\n    # deserialize data into str\n    try:\n        # validation\n        instance.anyof_schema_1_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_1_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n    # deserialize data into int\n    try:\n        # validation\n        instance.anyof_schema_2_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_2_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n\n    if error_messages:\n        # no match\n        raise ValueError(\"No match found when deserializing the JSON string into LocationInner with anyOf schemas: int, str. Details: \" + \", \".join(error_messages))\n    else:\n        return instance\n</code></pre>"},{"location":"API_Documentation/models/location_inner/#cheshire_cat_api.models.location_inner.LocationInner.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns the dict representation of the actual instance</p> Source code in <code>cheshire_cat_api/models/location_inner.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"Returns the dict representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return \"null\"\n\n    to_json = getattr(self.actual_instance, \"to_json\", None)\n    if callable(to_json):\n        return self.actual_instance.to_dict()\n    else:\n        return json.dumps(self.actual_instance)\n</code></pre>"},{"location":"API_Documentation/models/location_inner/#cheshire_cat_api.models.location_inner.LocationInner.to_json","title":"<code>to_json()</code>","text":"<p>Returns the JSON representation of the actual instance</p> Source code in <code>cheshire_cat_api/models/location_inner.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return \"null\"\n\n    to_json = getattr(self.actual_instance, \"to_json\", None)\n    if callable(to_json):\n        return self.actual_instance.to_json()\n    else:\n        return json.dumps(self.actual_instance)\n</code></pre>"},{"location":"API_Documentation/models/location_inner/#cheshire_cat_api.models.location_inner.LocationInner.to_str","title":"<code>to_str()</code>","text":"<p>Returns the string representation of the actual instance</p> Source code in <code>cheshire_cat_api/models/location_inner.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the actual instance\"\"\"\n    return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"API_Documentation/models/setting_body/","title":"setting_body","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/models/setting_body/#cheshire_cat_api.models.setting_body.SettingBody","title":"<code>SettingBody</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>SettingBody</p> Source code in <code>cheshire_cat_api/models/setting_body.py</code> <pre><code>class SettingBody(BaseModel):\n    \"\"\"\n    SettingBody\n    \"\"\" # noqa: E501\n    name: StrictStr\n    value: Value\n    category: Optional[StrictStr] = None\n    __properties: ClassVar[List[str]] = [\"name\", \"value\", \"category\"]\n\n    model_config = {\n        \"populate_by_name\": True,\n        \"validate_assignment\": True\n    }\n\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Create an instance of SettingBody from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude={\n            },\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of value\n        if self.value:\n            _dict['value'] = self.value.to_dict()\n        # set to None if category (nullable) is None\n        # and model_fields_set contains the field\n        if self.category is None and \"category\" in self.model_fields_set:\n            _dict['category'] = None\n\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: Dict) -&gt; Self:\n        \"\"\"Create an instance of SettingBody from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"name\": obj.get(\"name\"),\n            \"value\": Value.from_dict(obj.get(\"value\")) if obj.get(\"value\") is not None else None,\n            \"category\": obj.get(\"category\")\n        })\n        return _obj\n</code></pre>"},{"location":"API_Documentation/models/setting_body/#cheshire_cat_api.models.setting_body.SettingBody.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Create an instance of SettingBody from a dict</p> Source code in <code>cheshire_cat_api/models/setting_body.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: Dict) -&gt; Self:\n    \"\"\"Create an instance of SettingBody from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"name\": obj.get(\"name\"),\n        \"value\": Value.from_dict(obj.get(\"value\")) if obj.get(\"value\") is not None else None,\n        \"category\": obj.get(\"category\")\n    })\n    return _obj\n</code></pre>"},{"location":"API_Documentation/models/setting_body/#cheshire_cat_api.models.setting_body.SettingBody.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Create an instance of SettingBody from a JSON string</p> Source code in <code>cheshire_cat_api/models/setting_body.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Create an instance of SettingBody from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"API_Documentation/models/setting_body/#cheshire_cat_api.models.setting_body.SettingBody.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>cheshire_cat_api/models/setting_body.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude={\n        },\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of value\n    if self.value:\n        _dict['value'] = self.value.to_dict()\n    # set to None if category (nullable) is None\n    # and model_fields_set contains the field\n    if self.category is None and \"category\" in self.model_fields_set:\n        _dict['category'] = None\n\n    return _dict\n</code></pre>"},{"location":"API_Documentation/models/setting_body/#cheshire_cat_api.models.setting_body.SettingBody.to_json","title":"<code>to_json()</code>","text":"<p>Returns the JSON representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/setting_body.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"API_Documentation/models/setting_body/#cheshire_cat_api.models.setting_body.SettingBody.to_str","title":"<code>to_str()</code>","text":"<p>Returns the string representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/setting_body.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"API_Documentation/models/validation_error/","title":"validation_error","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/models/validation_error/#cheshire_cat_api.models.validation_error.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>ValidationError</p> Source code in <code>cheshire_cat_api/models/validation_error.py</code> <pre><code>class ValidationError(BaseModel):\n    \"\"\"\n    ValidationError\n    \"\"\" # noqa: E501\n    loc: List[LocationInner]\n    msg: StrictStr\n    type: StrictStr\n    __properties: ClassVar[List[str]] = [\"loc\", \"msg\", \"type\"]\n\n    model_config = {\n        \"populate_by_name\": True,\n        \"validate_assignment\": True\n    }\n\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.model_dump(by_alias=True))\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Create an instance of ValidationError from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Return the dictionary representation of the model using alias.\n\n        This has the following differences from calling pydantic's\n        `self.model_dump(by_alias=True)`:\n\n        * `None` is only added to the output dict for nullable fields that\n          were set at model initialization. Other fields with value `None`\n          are ignored.\n        \"\"\"\n        _dict = self.model_dump(\n            by_alias=True,\n            exclude={\n            },\n            exclude_none=True,\n        )\n        # override the default output from pydantic by calling `to_dict()` of each item in loc (list)\n        _items = []\n        if self.loc:\n            for _item in self.loc:\n                if _item:\n                    _items.append(_item.to_dict())\n            _dict['loc'] = _items\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: Dict) -&gt; Self:\n        \"\"\"Create an instance of ValidationError from a dict\"\"\"\n        if obj is None:\n            return None\n\n        if not isinstance(obj, dict):\n            return cls.model_validate(obj)\n\n        _obj = cls.model_validate({\n            \"loc\": [LocationInner.from_dict(_item) for _item in obj.get(\"loc\")] if obj.get(\"loc\") is not None else None,\n            \"msg\": obj.get(\"msg\"),\n            \"type\": obj.get(\"type\")\n        })\n        return _obj\n</code></pre>"},{"location":"API_Documentation/models/validation_error/#cheshire_cat_api.models.validation_error.ValidationError.from_dict","title":"<code>from_dict(obj)</code>  <code>classmethod</code>","text":"<p>Create an instance of ValidationError from a dict</p> Source code in <code>cheshire_cat_api/models/validation_error.py</code> <pre><code>@classmethod\ndef from_dict(cls, obj: Dict) -&gt; Self:\n    \"\"\"Create an instance of ValidationError from a dict\"\"\"\n    if obj is None:\n        return None\n\n    if not isinstance(obj, dict):\n        return cls.model_validate(obj)\n\n    _obj = cls.model_validate({\n        \"loc\": [LocationInner.from_dict(_item) for _item in obj.get(\"loc\")] if obj.get(\"loc\") is not None else None,\n        \"msg\": obj.get(\"msg\"),\n        \"type\": obj.get(\"type\")\n    })\n    return _obj\n</code></pre>"},{"location":"API_Documentation/models/validation_error/#cheshire_cat_api.models.validation_error.ValidationError.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Create an instance of ValidationError from a JSON string</p> Source code in <code>cheshire_cat_api/models/validation_error.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Create an instance of ValidationError from a JSON string\"\"\"\n    return cls.from_dict(json.loads(json_str))\n</code></pre>"},{"location":"API_Documentation/models/validation_error/#cheshire_cat_api.models.validation_error.ValidationError.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the dictionary representation of the model using alias.</p> <p>This has the following differences from calling pydantic's <code>self.model_dump(by_alias=True)</code>:</p> <ul> <li><code>None</code> is only added to the output dict for nullable fields that   were set at model initialization. Other fields with value <code>None</code>   are ignored.</li> </ul> Source code in <code>cheshire_cat_api/models/validation_error.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return the dictionary representation of the model using alias.\n\n    This has the following differences from calling pydantic's\n    `self.model_dump(by_alias=True)`:\n\n    * `None` is only added to the output dict for nullable fields that\n      were set at model initialization. Other fields with value `None`\n      are ignored.\n    \"\"\"\n    _dict = self.model_dump(\n        by_alias=True,\n        exclude={\n        },\n        exclude_none=True,\n    )\n    # override the default output from pydantic by calling `to_dict()` of each item in loc (list)\n    _items = []\n    if self.loc:\n        for _item in self.loc:\n            if _item:\n                _items.append(_item.to_dict())\n        _dict['loc'] = _items\n    return _dict\n</code></pre>"},{"location":"API_Documentation/models/validation_error/#cheshire_cat_api.models.validation_error.ValidationError.to_json","title":"<code>to_json()</code>","text":"<p>Returns the JSON representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/validation_error.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the model using alias\"\"\"\n    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"API_Documentation/models/validation_error/#cheshire_cat_api.models.validation_error.ValidationError.to_str","title":"<code>to_str()</code>","text":"<p>Returns the string representation of the model using alias</p> Source code in <code>cheshire_cat_api/models/validation_error.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the model using alias\"\"\"\n    return pprint.pformat(self.model_dump(by_alias=True))\n</code></pre>"},{"location":"API_Documentation/models/value/","title":"value","text":"<p>\ud83d\ude38 Cheshire-Cat API</p> <p>Production ready AI assistant framework</p> <p>The version of the OpenAPI document: 1.3.1 Generated by OpenAPI Generator (https://openapi-generator.tech)</p> <p>Do not edit the class manually.</p>"},{"location":"API_Documentation/models/value/#cheshire_cat_api.models.value.Value","title":"<code>Value</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Value</p> Source code in <code>cheshire_cat_api/models/value.py</code> <pre><code>class Value(BaseModel):\n    \"\"\"\n    Value\n    \"\"\"\n\n    # data type: object\n    anyof_schema_1_validator: Optional[Union[str, Any]] = None\n    # data type: List[object]\n    anyof_schema_2_validator: Optional[List[Any]] = None\n    if TYPE_CHECKING:\n        actual_instance: Optional[Union[List[object], object]] = None\n    else:\n        actual_instance: Any = None\n    any_of_schemas: List[str] = Literal[VALUE_ANY_OF_SCHEMAS]\n\n    model_config = {\n        \"validate_assignment\": True\n    }\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        if args:\n            if len(args) &gt; 1:\n                raise ValueError(\"If a position argument is used, only 1 is allowed to set `actual_instance`\")\n            if kwargs:\n                raise ValueError(\"If a position argument is used, keyword arguments cannot be used.\")\n            super().__init__(actual_instance=args[0])\n        else:\n            super().__init__(**kwargs)\n\n    @field_validator('actual_instance')\n    def actual_instance_must_validate_anyof(cls, v):\n        instance = Value.model_construct()\n        error_messages = []\n        # validate data type: object\n        try:\n            instance.anyof_schema_1_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # validate data type: List[object]\n        try:\n            instance.anyof_schema_2_validator = v\n            return v\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        if error_messages:\n            # no match\n            raise ValueError(\"No match found when setting the actual_instance in Value with anyOf schemas: List[object], object. Details: \" + \", \".join(error_messages))\n        else:\n            return v\n\n    @classmethod\n    def from_dict(cls, obj: dict) -&gt; Self:\n        return cls.from_json(json.dumps(obj))\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; Self:\n        \"\"\"Returns the object represented by the json string\"\"\"\n        instance = cls.model_construct()\n        error_messages = []\n        # deserialize data into object\n        try:\n            # validation\n            instance.anyof_schema_1_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_1_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n        # deserialize data into List[object]\n        try:\n            # validation\n            instance.anyof_schema_2_validator = json.loads(json_str)\n            # assign value to actual_instance\n            instance.actual_instance = instance.anyof_schema_2_validator\n            return instance\n        except (ValidationError, ValueError) as e:\n            error_messages.append(str(e))\n\n        if error_messages:\n            # no match\n            raise ValueError(\"No match found when deserializing the JSON string into Value with anyOf schemas: List[object], object. Details: \" + \", \".join(error_messages))\n        else:\n            return instance\n\n    def to_json(self) -&gt; str:\n        \"\"\"Returns the JSON representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return \"null\"\n\n        to_json = getattr(self.actual_instance, \"to_json\", None)\n        if callable(to_json):\n            return self.actual_instance.to_json()\n        else:\n            return json.dumps(self.actual_instance)\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"Returns the dict representation of the actual instance\"\"\"\n        if self.actual_instance is None:\n            return \"null\"\n\n        to_json = getattr(self.actual_instance, \"to_json\", None)\n        if callable(to_json):\n            return self.actual_instance.to_dict()\n        else:\n            return json.dumps(self.actual_instance)\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the actual instance\"\"\"\n        return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"API_Documentation/models/value/#cheshire_cat_api.models.value.Value.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Returns the object represented by the json string</p> Source code in <code>cheshire_cat_api/models/value.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; Self:\n    \"\"\"Returns the object represented by the json string\"\"\"\n    instance = cls.model_construct()\n    error_messages = []\n    # deserialize data into object\n    try:\n        # validation\n        instance.anyof_schema_1_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_1_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n    # deserialize data into List[object]\n    try:\n        # validation\n        instance.anyof_schema_2_validator = json.loads(json_str)\n        # assign value to actual_instance\n        instance.actual_instance = instance.anyof_schema_2_validator\n        return instance\n    except (ValidationError, ValueError) as e:\n        error_messages.append(str(e))\n\n    if error_messages:\n        # no match\n        raise ValueError(\"No match found when deserializing the JSON string into Value with anyOf schemas: List[object], object. Details: \" + \", \".join(error_messages))\n    else:\n        return instance\n</code></pre>"},{"location":"API_Documentation/models/value/#cheshire_cat_api.models.value.Value.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns the dict representation of the actual instance</p> Source code in <code>cheshire_cat_api/models/value.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"Returns the dict representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return \"null\"\n\n    to_json = getattr(self.actual_instance, \"to_json\", None)\n    if callable(to_json):\n        return self.actual_instance.to_dict()\n    else:\n        return json.dumps(self.actual_instance)\n</code></pre>"},{"location":"API_Documentation/models/value/#cheshire_cat_api.models.value.Value.to_json","title":"<code>to_json()</code>","text":"<p>Returns the JSON representation of the actual instance</p> Source code in <code>cheshire_cat_api/models/value.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Returns the JSON representation of the actual instance\"\"\"\n    if self.actual_instance is None:\n        return \"null\"\n\n    to_json = getattr(self.actual_instance, \"to_json\", None)\n    if callable(to_json):\n        return self.actual_instance.to_json()\n    else:\n        return json.dumps(self.actual_instance)\n</code></pre>"},{"location":"API_Documentation/models/value/#cheshire_cat_api.models.value.Value.to_str","title":"<code>to_str()</code>","text":"<p>Returns the string representation of the actual instance</p> Source code in <code>cheshire_cat_api/models/value.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the actual instance\"\"\"\n    return pprint.pformat(self.model_dump())\n</code></pre>"},{"location":"getting_started/examples/","title":"Coming soon...","text":""},{"location":"getting_started/installation/","title":"Coming soon...","text":""}]}